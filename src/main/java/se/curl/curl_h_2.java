// Generated by jextract

package se.curl;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class curl_h_2 {

    curl_h_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("curl"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int LIBCURL_VERSION_MAJOR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LIBCURL_VERSION_MAJOR 8
     * }
     */
    public static int LIBCURL_VERSION_MAJOR() {
        return LIBCURL_VERSION_MAJOR;
    }
    private static final int LIBCURL_VERSION_MINOR = (int)10L;
    /**
     * {@snippet lang=c :
     * #define LIBCURL_VERSION_MINOR 10
     * }
     */
    public static int LIBCURL_VERSION_MINOR() {
        return LIBCURL_VERSION_MINOR;
    }
    private static final int LIBCURL_VERSION_PATCH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LIBCURL_VERSION_PATCH 1
     * }
     */
    public static int LIBCURL_VERSION_PATCH() {
        return LIBCURL_VERSION_PATCH;
    }
    private static final int LIBCURL_VERSION_NUM = (int)526849L;
    /**
     * {@snippet lang=c :
     * #define LIBCURL_VERSION_NUM 526849
     * }
     */
    public static int LIBCURL_VERSION_NUM() {
        return LIBCURL_VERSION_NUM;
    }
    private static final int CURL_PULL_SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_PULL_SYS_TYPES_H 1
     * }
     */
    public static int CURL_PULL_SYS_TYPES_H() {
        return CURL_PULL_SYS_TYPES_H;
    }
    private static final int CURL_PULL_SYS_SOCKET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_PULL_SYS_SOCKET_H 1
     * }
     */
    public static int CURL_PULL_SYS_SOCKET_H() {
        return CURL_PULL_SYS_SOCKET_H;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC23 0
     * }
     */
    public static int __GLIBC_USE_ISOC23() {
        return __GLIBC_USE_ISOC23;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_TIME_BITS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_TIME_BITS64 1
     * }
     */
    public static int __USE_TIME_BITS64() {
        return __USE_TIME_BITS64;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C23_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C23_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C23_STRTOL() {
        return __GLIBC_USE_C23_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 40
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _SYS_SOCKET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SOCKET_H 1
     * }
     */
    public static int _SYS_SOCKET_H() {
        return _SYS_SOCKET_H;
    }
    private static final int __iovec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __iovec_defined 1
     * }
     */
    public static int __iovec_defined() {
        return __iovec_defined;
    }
    private static final int PF_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PF_UNSPEC 0
     * }
     */
    public static int PF_UNSPEC() {
        return PF_UNSPEC;
    }
    private static final int PF_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_LOCAL 1
     * }
     */
    public static int PF_LOCAL() {
        return PF_LOCAL;
    }
    private static final int PF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PF_INET 2
     * }
     */
    public static int PF_INET() {
        return PF_INET;
    }
    private static final int PF_AX25 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PF_AX25 3
     * }
     */
    public static int PF_AX25() {
        return PF_AX25;
    }
    private static final int PF_IPX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PF_IPX 4
     * }
     */
    public static int PF_IPX() {
        return PF_IPX;
    }
    private static final int PF_APPLETALK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PF_APPLETALK 5
     * }
     */
    public static int PF_APPLETALK() {
        return PF_APPLETALK;
    }
    private static final int PF_NETROM = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PF_NETROM 6
     * }
     */
    public static int PF_NETROM() {
        return PF_NETROM;
    }
    private static final int PF_BRIDGE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PF_BRIDGE 7
     * }
     */
    public static int PF_BRIDGE() {
        return PF_BRIDGE;
    }
    private static final int PF_ATMPVC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMPVC 8
     * }
     */
    public static int PF_ATMPVC() {
        return PF_ATMPVC;
    }
    private static final int PF_X25 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PF_X25 9
     * }
     */
    public static int PF_X25() {
        return PF_X25;
    }
    private static final int PF_INET6 = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PF_INET6 10
     * }
     */
    public static int PF_INET6() {
        return PF_INET6;
    }
    private static final int PF_ROSE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PF_ROSE 11
     * }
     */
    public static int PF_ROSE() {
        return PF_ROSE;
    }
    private static final int PF_DECnet = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PF_DECnet 12
     * }
     */
    public static int PF_DECnet() {
        return PF_DECnet;
    }
    private static final int PF_NETBEUI = (int)13L;
    /**
     * {@snippet lang=c :
     * #define PF_NETBEUI 13
     * }
     */
    public static int PF_NETBEUI() {
        return PF_NETBEUI;
    }
    private static final int PF_SECURITY = (int)14L;
    /**
     * {@snippet lang=c :
     * #define PF_SECURITY 14
     * }
     */
    public static int PF_SECURITY() {
        return PF_SECURITY;
    }
    private static final int PF_KEY = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PF_KEY 15
     * }
     */
    public static int PF_KEY() {
        return PF_KEY;
    }
    private static final int PF_NETLINK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PF_NETLINK 16
     * }
     */
    public static int PF_NETLINK() {
        return PF_NETLINK;
    }
    private static final int PF_PACKET = (int)17L;
    /**
     * {@snippet lang=c :
     * #define PF_PACKET 17
     * }
     */
    public static int PF_PACKET() {
        return PF_PACKET;
    }
    private static final int PF_ASH = (int)18L;
    /**
     * {@snippet lang=c :
     * #define PF_ASH 18
     * }
     */
    public static int PF_ASH() {
        return PF_ASH;
    }
    private static final int PF_ECONET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define PF_ECONET 19
     * }
     */
    public static int PF_ECONET() {
        return PF_ECONET;
    }
    private static final int PF_ATMSVC = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMSVC 20
     * }
     */
    public static int PF_ATMSVC() {
        return PF_ATMSVC;
    }
    private static final int PF_RDS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define PF_RDS 21
     * }
     */
    public static int PF_RDS() {
        return PF_RDS;
    }
    private static final int PF_SNA = (int)22L;
    /**
     * {@snippet lang=c :
     * #define PF_SNA 22
     * }
     */
    public static int PF_SNA() {
        return PF_SNA;
    }
    private static final int PF_IRDA = (int)23L;
    /**
     * {@snippet lang=c :
     * #define PF_IRDA 23
     * }
     */
    public static int PF_IRDA() {
        return PF_IRDA;
    }
    private static final int PF_PPPOX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PF_PPPOX 24
     * }
     */
    public static int PF_PPPOX() {
        return PF_PPPOX;
    }
    private static final int PF_WANPIPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define PF_WANPIPE 25
     * }
     */
    public static int PF_WANPIPE() {
        return PF_WANPIPE;
    }
    private static final int PF_LLC = (int)26L;
    /**
     * {@snippet lang=c :
     * #define PF_LLC 26
     * }
     */
    public static int PF_LLC() {
        return PF_LLC;
    }
    private static final int PF_IB = (int)27L;
    /**
     * {@snippet lang=c :
     * #define PF_IB 27
     * }
     */
    public static int PF_IB() {
        return PF_IB;
    }
    private static final int PF_MPLS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define PF_MPLS 28
     * }
     */
    public static int PF_MPLS() {
        return PF_MPLS;
    }
    private static final int PF_CAN = (int)29L;
    /**
     * {@snippet lang=c :
     * #define PF_CAN 29
     * }
     */
    public static int PF_CAN() {
        return PF_CAN;
    }
    private static final int PF_TIPC = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PF_TIPC 30
     * }
     */
    public static int PF_TIPC() {
        return PF_TIPC;
    }
    private static final int PF_BLUETOOTH = (int)31L;
    /**
     * {@snippet lang=c :
     * #define PF_BLUETOOTH 31
     * }
     */
    public static int PF_BLUETOOTH() {
        return PF_BLUETOOTH;
    }
    private static final int PF_IUCV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define PF_IUCV 32
     * }
     */
    public static int PF_IUCV() {
        return PF_IUCV;
    }
    private static final int PF_RXRPC = (int)33L;
    /**
     * {@snippet lang=c :
     * #define PF_RXRPC 33
     * }
     */
    public static int PF_RXRPC() {
        return PF_RXRPC;
    }
    private static final int PF_ISDN = (int)34L;
    /**
     * {@snippet lang=c :
     * #define PF_ISDN 34
     * }
     */
    public static int PF_ISDN() {
        return PF_ISDN;
    }
    private static final int PF_PHONET = (int)35L;
    /**
     * {@snippet lang=c :
     * #define PF_PHONET 35
     * }
     */
    public static int PF_PHONET() {
        return PF_PHONET;
    }
    private static final int PF_IEEE802154 = (int)36L;
    /**
     * {@snippet lang=c :
     * #define PF_IEEE802154 36
     * }
     */
    public static int PF_IEEE802154() {
        return PF_IEEE802154;
    }
    private static final int PF_CAIF = (int)37L;
    /**
     * {@snippet lang=c :
     * #define PF_CAIF 37
     * }
     */
    public static int PF_CAIF() {
        return PF_CAIF;
    }
    private static final int PF_ALG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define PF_ALG 38
     * }
     */
    public static int PF_ALG() {
        return PF_ALG;
    }
    private static final int PF_NFC = (int)39L;
    /**
     * {@snippet lang=c :
     * #define PF_NFC 39
     * }
     */
    public static int PF_NFC() {
        return PF_NFC;
    }
    private static final int PF_VSOCK = (int)40L;
    /**
     * {@snippet lang=c :
     * #define PF_VSOCK 40
     * }
     */
    public static int PF_VSOCK() {
        return PF_VSOCK;
    }
    private static final int PF_KCM = (int)41L;
    /**
     * {@snippet lang=c :
     * #define PF_KCM 41
     * }
     */
    public static int PF_KCM() {
        return PF_KCM;
    }
    private static final int PF_QIPCRTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define PF_QIPCRTR 42
     * }
     */
    public static int PF_QIPCRTR() {
        return PF_QIPCRTR;
    }
    private static final int PF_SMC = (int)43L;
    /**
     * {@snippet lang=c :
     * #define PF_SMC 43
     * }
     */
    public static int PF_SMC() {
        return PF_SMC;
    }
    private static final int PF_XDP = (int)44L;
    /**
     * {@snippet lang=c :
     * #define PF_XDP 44
     * }
     */
    public static int PF_XDP() {
        return PF_XDP;
    }
    private static final int PF_MCTP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define PF_MCTP 45
     * }
     */
    public static int PF_MCTP() {
        return PF_MCTP;
    }
    private static final int PF_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define PF_MAX 46
     * }
     */
    public static int PF_MAX() {
        return PF_MAX;
    }
    private static final int SOL_RAW = (int)255L;
    /**
     * {@snippet lang=c :
     * #define SOL_RAW 255
     * }
     */
    public static int SOL_RAW() {
        return SOL_RAW;
    }
    private static final int SOL_DECNET = (int)261L;
    /**
     * {@snippet lang=c :
     * #define SOL_DECNET 261
     * }
     */
    public static int SOL_DECNET() {
        return SOL_DECNET;
    }
    private static final int SOL_X25 = (int)262L;
    /**
     * {@snippet lang=c :
     * #define SOL_X25 262
     * }
     */
    public static int SOL_X25() {
        return SOL_X25;
    }
    private static final int SOL_PACKET = (int)263L;
    /**
     * {@snippet lang=c :
     * #define SOL_PACKET 263
     * }
     */
    public static int SOL_PACKET() {
        return SOL_PACKET;
    }
    private static final int SOL_ATM = (int)264L;
    /**
     * {@snippet lang=c :
     * #define SOL_ATM 264
     * }
     */
    public static int SOL_ATM() {
        return SOL_ATM;
    }
    private static final int SOL_AAL = (int)265L;
    /**
     * {@snippet lang=c :
     * #define SOL_AAL 265
     * }
     */
    public static int SOL_AAL() {
        return SOL_AAL;
    }
    private static final int SOL_IRDA = (int)266L;
    /**
     * {@snippet lang=c :
     * #define SOL_IRDA 266
     * }
     */
    public static int SOL_IRDA() {
        return SOL_IRDA;
    }
    private static final int SOL_NETBEUI = (int)267L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETBEUI 267
     * }
     */
    public static int SOL_NETBEUI() {
        return SOL_NETBEUI;
    }
    private static final int SOL_LLC = (int)268L;
    /**
     * {@snippet lang=c :
     * #define SOL_LLC 268
     * }
     */
    public static int SOL_LLC() {
        return SOL_LLC;
    }
    private static final int SOL_DCCP = (int)269L;
    /**
     * {@snippet lang=c :
     * #define SOL_DCCP 269
     * }
     */
    public static int SOL_DCCP() {
        return SOL_DCCP;
    }
    private static final int SOL_NETLINK = (int)270L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETLINK 270
     * }
     */
    public static int SOL_NETLINK() {
        return SOL_NETLINK;
    }
    private static final int SOL_TIPC = (int)271L;
    /**
     * {@snippet lang=c :
     * #define SOL_TIPC 271
     * }
     */
    public static int SOL_TIPC() {
        return SOL_TIPC;
    }
    private static final int SOL_RXRPC = (int)272L;
    /**
     * {@snippet lang=c :
     * #define SOL_RXRPC 272
     * }
     */
    public static int SOL_RXRPC() {
        return SOL_RXRPC;
    }
    private static final int SOL_PPPOL2TP = (int)273L;
    /**
     * {@snippet lang=c :
     * #define SOL_PPPOL2TP 273
     * }
     */
    public static int SOL_PPPOL2TP() {
        return SOL_PPPOL2TP;
    }
    private static final int SOL_BLUETOOTH = (int)274L;
    /**
     * {@snippet lang=c :
     * #define SOL_BLUETOOTH 274
     * }
     */
    public static int SOL_BLUETOOTH() {
        return SOL_BLUETOOTH;
    }
    private static final int SOL_PNPIPE = (int)275L;
    /**
     * {@snippet lang=c :
     * #define SOL_PNPIPE 275
     * }
     */
    public static int SOL_PNPIPE() {
        return SOL_PNPIPE;
    }
    private static final int SOL_RDS = (int)276L;
    /**
     * {@snippet lang=c :
     * #define SOL_RDS 276
     * }
     */
    public static int SOL_RDS() {
        return SOL_RDS;
    }
    private static final int SOL_IUCV = (int)277L;
    /**
     * {@snippet lang=c :
     * #define SOL_IUCV 277
     * }
     */
    public static int SOL_IUCV() {
        return SOL_IUCV;
    }
    private static final int SOL_CAIF = (int)278L;
    /**
     * {@snippet lang=c :
     * #define SOL_CAIF 278
     * }
     */
    public static int SOL_CAIF() {
        return SOL_CAIF;
    }
    private static final int SOL_ALG = (int)279L;
    /**
     * {@snippet lang=c :
     * #define SOL_ALG 279
     * }
     */
    public static int SOL_ALG() {
        return SOL_ALG;
    }
    private static final int SOL_NFC = (int)280L;
    /**
     * {@snippet lang=c :
     * #define SOL_NFC 280
     * }
     */
    public static int SOL_NFC() {
        return SOL_NFC;
    }
    private static final int SOL_KCM = (int)281L;
    /**
     * {@snippet lang=c :
     * #define SOL_KCM 281
     * }
     */
    public static int SOL_KCM() {
        return SOL_KCM;
    }
    private static final int SOL_TLS = (int)282L;
    /**
     * {@snippet lang=c :
     * #define SOL_TLS 282
     * }
     */
    public static int SOL_TLS() {
        return SOL_TLS;
    }
    private static final int SOL_XDP = (int)283L;
    /**
     * {@snippet lang=c :
     * #define SOL_XDP 283
     * }
     */
    public static int SOL_XDP() {
        return SOL_XDP;
    }
    private static final int SOL_MPTCP = (int)284L;
    /**
     * {@snippet lang=c :
     * #define SOL_MPTCP 284
     * }
     */
    public static int SOL_MPTCP() {
        return SOL_MPTCP;
    }
    private static final int SOL_MCTP = (int)285L;
    /**
     * {@snippet lang=c :
     * #define SOL_MCTP 285
     * }
     */
    public static int SOL_MCTP() {
        return SOL_MCTP;
    }
    private static final int SOL_SMC = (int)286L;
    /**
     * {@snippet lang=c :
     * #define SOL_SMC 286
     * }
     */
    public static int SOL_SMC() {
        return SOL_SMC;
    }
    private static final int SOL_VSOCK = (int)287L;
    /**
     * {@snippet lang=c :
     * #define SOL_VSOCK 287
     * }
     */
    public static int SOL_VSOCK() {
        return SOL_VSOCK;
    }
    private static final int SOMAXCONN = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define SOMAXCONN 4096
     * }
     */
    public static int SOMAXCONN() {
        return SOMAXCONN;
    }
    private static final int _BITS_SOCKADDR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SOCKADDR_H 1
     * }
     */
    public static int _BITS_SOCKADDR_H() {
        return _BITS_SOCKADDR_H;
    }
    private static final int _SS_SIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SS_SIZE 128
     * }
     */
    public static int _SS_SIZE() {
        return _SS_SIZE;
    }
    private static final int __BITS_PER_LONG = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __BITS_PER_LONG 64
     * }
     */
    public static int __BITS_PER_LONG() {
        return __BITS_PER_LONG;
    }
    private static final int __BITS_PER_LONG_LONG = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __BITS_PER_LONG_LONG 64
     * }
     */
    public static int __BITS_PER_LONG_LONG() {
        return __BITS_PER_LONG_LONG;
    }
    private static final int FIOSETOWN = (int)35073L;
    /**
     * {@snippet lang=c :
     * #define FIOSETOWN 35073
     * }
     */
    public static int FIOSETOWN() {
        return FIOSETOWN;
    }
    private static final int SIOCSPGRP = (int)35074L;
    /**
     * {@snippet lang=c :
     * #define SIOCSPGRP 35074
     * }
     */
    public static int SIOCSPGRP() {
        return SIOCSPGRP;
    }
    private static final int FIOGETOWN = (int)35075L;
    /**
     * {@snippet lang=c :
     * #define FIOGETOWN 35075
     * }
     */
    public static int FIOGETOWN() {
        return FIOGETOWN;
    }
    private static final int SIOCGPGRP = (int)35076L;
    /**
     * {@snippet lang=c :
     * #define SIOCGPGRP 35076
     * }
     */
    public static int SIOCGPGRP() {
        return SIOCGPGRP;
    }
    private static final int SIOCATMARK = (int)35077L;
    /**
     * {@snippet lang=c :
     * #define SIOCATMARK 35077
     * }
     */
    public static int SIOCATMARK() {
        return SIOCATMARK;
    }
    private static final int SIOCGSTAMP_OLD = (int)35078L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMP_OLD 35078
     * }
     */
    public static int SIOCGSTAMP_OLD() {
        return SIOCGSTAMP_OLD;
    }
    private static final int SIOCGSTAMPNS_OLD = (int)35079L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMPNS_OLD 35079
     * }
     */
    public static int SIOCGSTAMPNS_OLD() {
        return SIOCGSTAMPNS_OLD;
    }
    private static final int SOL_SOCKET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SOL_SOCKET 1
     * }
     */
    public static int SOL_SOCKET() {
        return SOL_SOCKET;
    }
    private static final int SO_DEBUG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SO_DEBUG 1
     * }
     */
    public static int SO_DEBUG() {
        return SO_DEBUG;
    }
    private static final int SO_REUSEADDR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEADDR 2
     * }
     */
    public static int SO_REUSEADDR() {
        return SO_REUSEADDR;
    }
    private static final int SO_TYPE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SO_TYPE 3
     * }
     */
    public static int SO_TYPE() {
        return SO_TYPE;
    }
    private static final int SO_ERROR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SO_ERROR 4
     * }
     */
    public static int SO_ERROR() {
        return SO_ERROR;
    }
    private static final int SO_DONTROUTE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SO_DONTROUTE 5
     * }
     */
    public static int SO_DONTROUTE() {
        return SO_DONTROUTE;
    }
    private static final int SO_BROADCAST = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SO_BROADCAST 6
     * }
     */
    public static int SO_BROADCAST() {
        return SO_BROADCAST;
    }
    private static final int SO_SNDBUF = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUF 7
     * }
     */
    public static int SO_SNDBUF() {
        return SO_SNDBUF;
    }
    private static final int SO_RCVBUF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUF 8
     * }
     */
    public static int SO_RCVBUF() {
        return SO_RCVBUF;
    }
    private static final int SO_SNDBUFFORCE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUFFORCE 32
     * }
     */
    public static int SO_SNDBUFFORCE() {
        return SO_SNDBUFFORCE;
    }
    private static final int SO_RCVBUFFORCE = (int)33L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUFFORCE 33
     * }
     */
    public static int SO_RCVBUFFORCE() {
        return SO_RCVBUFFORCE;
    }
    private static final int SO_KEEPALIVE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SO_KEEPALIVE 9
     * }
     */
    public static int SO_KEEPALIVE() {
        return SO_KEEPALIVE;
    }
    private static final int SO_OOBINLINE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SO_OOBINLINE 10
     * }
     */
    public static int SO_OOBINLINE() {
        return SO_OOBINLINE;
    }
    private static final int SO_NO_CHECK = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SO_NO_CHECK 11
     * }
     */
    public static int SO_NO_CHECK() {
        return SO_NO_CHECK;
    }
    private static final int SO_PRIORITY = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SO_PRIORITY 12
     * }
     */
    public static int SO_PRIORITY() {
        return SO_PRIORITY;
    }
    private static final int SO_LINGER = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SO_LINGER 13
     * }
     */
    public static int SO_LINGER() {
        return SO_LINGER;
    }
    private static final int SO_BSDCOMPAT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SO_BSDCOMPAT 14
     * }
     */
    public static int SO_BSDCOMPAT() {
        return SO_BSDCOMPAT;
    }
    private static final int SO_REUSEPORT = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEPORT 15
     * }
     */
    public static int SO_REUSEPORT() {
        return SO_REUSEPORT;
    }
    private static final int SO_PASSCRED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSCRED 16
     * }
     */
    public static int SO_PASSCRED() {
        return SO_PASSCRED;
    }
    private static final int SO_PEERCRED = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERCRED 17
     * }
     */
    public static int SO_PEERCRED() {
        return SO_PEERCRED;
    }
    private static final int SO_RCVLOWAT = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVLOWAT 18
     * }
     */
    public static int SO_RCVLOWAT() {
        return SO_RCVLOWAT;
    }
    private static final int SO_SNDLOWAT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDLOWAT 19
     * }
     */
    public static int SO_SNDLOWAT() {
        return SO_SNDLOWAT;
    }
    private static final int SO_RCVTIMEO_OLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_OLD 20
     * }
     */
    public static int SO_RCVTIMEO_OLD() {
        return SO_RCVTIMEO_OLD;
    }
    private static final int SO_SNDTIMEO_OLD = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_OLD 21
     * }
     */
    public static int SO_SNDTIMEO_OLD() {
        return SO_SNDTIMEO_OLD;
    }
    private static final int SO_SECURITY_AUTHENTICATION = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_AUTHENTICATION 22
     * }
     */
    public static int SO_SECURITY_AUTHENTICATION() {
        return SO_SECURITY_AUTHENTICATION;
    }
    private static final int SO_SECURITY_ENCRYPTION_TRANSPORT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_TRANSPORT 23
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_TRANSPORT() {
        return SO_SECURITY_ENCRYPTION_TRANSPORT;
    }
    private static final int SO_SECURITY_ENCRYPTION_NETWORK = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_NETWORK 24
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_NETWORK() {
        return SO_SECURITY_ENCRYPTION_NETWORK;
    }
    private static final int SO_BINDTODEVICE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTODEVICE 25
     * }
     */
    public static int SO_BINDTODEVICE() {
        return SO_BINDTODEVICE;
    }
    private static final int SO_ATTACH_FILTER = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_FILTER 26
     * }
     */
    public static int SO_ATTACH_FILTER() {
        return SO_ATTACH_FILTER;
    }
    private static final int SO_DETACH_FILTER = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_FILTER 27
     * }
     */
    public static int SO_DETACH_FILTER() {
        return SO_DETACH_FILTER;
    }
    private static final int SO_PEERNAME = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERNAME 28
     * }
     */
    public static int SO_PEERNAME() {
        return SO_PEERNAME;
    }
    private static final int SO_ACCEPTCONN = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SO_ACCEPTCONN 30
     * }
     */
    public static int SO_ACCEPTCONN() {
        return SO_ACCEPTCONN;
    }
    private static final int SO_PEERSEC = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERSEC 31
     * }
     */
    public static int SO_PEERSEC() {
        return SO_PEERSEC;
    }
    private static final int SO_PASSSEC = (int)34L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSSEC 34
     * }
     */
    public static int SO_PASSSEC() {
        return SO_PASSSEC;
    }
    private static final int SO_MARK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define SO_MARK 36
     * }
     */
    public static int SO_MARK() {
        return SO_MARK;
    }
    private static final int SO_PROTOCOL = (int)38L;
    /**
     * {@snippet lang=c :
     * #define SO_PROTOCOL 38
     * }
     */
    public static int SO_PROTOCOL() {
        return SO_PROTOCOL;
    }
    private static final int SO_DOMAIN = (int)39L;
    /**
     * {@snippet lang=c :
     * #define SO_DOMAIN 39
     * }
     */
    public static int SO_DOMAIN() {
        return SO_DOMAIN;
    }
    private static final int SO_RXQ_OVFL = (int)40L;
    /**
     * {@snippet lang=c :
     * #define SO_RXQ_OVFL 40
     * }
     */
    public static int SO_RXQ_OVFL() {
        return SO_RXQ_OVFL;
    }
    private static final int SO_WIFI_STATUS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SO_WIFI_STATUS 41
     * }
     */
    public static int SO_WIFI_STATUS() {
        return SO_WIFI_STATUS;
    }
    private static final int SO_PEEK_OFF = (int)42L;
    /**
     * {@snippet lang=c :
     * #define SO_PEEK_OFF 42
     * }
     */
    public static int SO_PEEK_OFF() {
        return SO_PEEK_OFF;
    }
    private static final int SO_NOFCS = (int)43L;
    /**
     * {@snippet lang=c :
     * #define SO_NOFCS 43
     * }
     */
    public static int SO_NOFCS() {
        return SO_NOFCS;
    }
    private static final int SO_LOCK_FILTER = (int)44L;
    /**
     * {@snippet lang=c :
     * #define SO_LOCK_FILTER 44
     * }
     */
    public static int SO_LOCK_FILTER() {
        return SO_LOCK_FILTER;
    }
    private static final int SO_SELECT_ERR_QUEUE = (int)45L;
    /**
     * {@snippet lang=c :
     * #define SO_SELECT_ERR_QUEUE 45
     * }
     */
    public static int SO_SELECT_ERR_QUEUE() {
        return SO_SELECT_ERR_QUEUE;
    }
    private static final int SO_BUSY_POLL = (int)46L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL 46
     * }
     */
    public static int SO_BUSY_POLL() {
        return SO_BUSY_POLL;
    }
    private static final int SO_MAX_PACING_RATE = (int)47L;
    /**
     * {@snippet lang=c :
     * #define SO_MAX_PACING_RATE 47
     * }
     */
    public static int SO_MAX_PACING_RATE() {
        return SO_MAX_PACING_RATE;
    }
    private static final int SO_BPF_EXTENSIONS = (int)48L;
    /**
     * {@snippet lang=c :
     * #define SO_BPF_EXTENSIONS 48
     * }
     */
    public static int SO_BPF_EXTENSIONS() {
        return SO_BPF_EXTENSIONS;
    }
    private static final int SO_INCOMING_CPU = (int)49L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_CPU 49
     * }
     */
    public static int SO_INCOMING_CPU() {
        return SO_INCOMING_CPU;
    }
    private static final int SO_ATTACH_BPF = (int)50L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_BPF 50
     * }
     */
    public static int SO_ATTACH_BPF() {
        return SO_ATTACH_BPF;
    }
    private static final int SO_ATTACH_REUSEPORT_CBPF = (int)51L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_CBPF 51
     * }
     */
    public static int SO_ATTACH_REUSEPORT_CBPF() {
        return SO_ATTACH_REUSEPORT_CBPF;
    }
    private static final int SO_ATTACH_REUSEPORT_EBPF = (int)52L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_EBPF 52
     * }
     */
    public static int SO_ATTACH_REUSEPORT_EBPF() {
        return SO_ATTACH_REUSEPORT_EBPF;
    }
    private static final int SO_CNX_ADVICE = (int)53L;
    /**
     * {@snippet lang=c :
     * #define SO_CNX_ADVICE 53
     * }
     */
    public static int SO_CNX_ADVICE() {
        return SO_CNX_ADVICE;
    }
    private static final int SCM_TIMESTAMPING_OPT_STATS = (int)54L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_OPT_STATS 54
     * }
     */
    public static int SCM_TIMESTAMPING_OPT_STATS() {
        return SCM_TIMESTAMPING_OPT_STATS;
    }
    private static final int SO_MEMINFO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define SO_MEMINFO 55
     * }
     */
    public static int SO_MEMINFO() {
        return SO_MEMINFO;
    }
    private static final int SO_INCOMING_NAPI_ID = (int)56L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_NAPI_ID 56
     * }
     */
    public static int SO_INCOMING_NAPI_ID() {
        return SO_INCOMING_NAPI_ID;
    }
    private static final int SO_COOKIE = (int)57L;
    /**
     * {@snippet lang=c :
     * #define SO_COOKIE 57
     * }
     */
    public static int SO_COOKIE() {
        return SO_COOKIE;
    }
    private static final int SCM_TIMESTAMPING_PKTINFO = (int)58L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_PKTINFO 58
     * }
     */
    public static int SCM_TIMESTAMPING_PKTINFO() {
        return SCM_TIMESTAMPING_PKTINFO;
    }
    private static final int SO_PEERGROUPS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERGROUPS 59
     * }
     */
    public static int SO_PEERGROUPS() {
        return SO_PEERGROUPS;
    }
    private static final int SO_ZEROCOPY = (int)60L;
    /**
     * {@snippet lang=c :
     * #define SO_ZEROCOPY 60
     * }
     */
    public static int SO_ZEROCOPY() {
        return SO_ZEROCOPY;
    }
    private static final int SO_TXTIME = (int)61L;
    /**
     * {@snippet lang=c :
     * #define SO_TXTIME 61
     * }
     */
    public static int SO_TXTIME() {
        return SO_TXTIME;
    }
    private static final int SO_BINDTOIFINDEX = (int)62L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTOIFINDEX 62
     * }
     */
    public static int SO_BINDTOIFINDEX() {
        return SO_BINDTOIFINDEX;
    }
    private static final int SO_TIMESTAMP_OLD = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_OLD 29
     * }
     */
    public static int SO_TIMESTAMP_OLD() {
        return SO_TIMESTAMP_OLD;
    }
    private static final int SO_TIMESTAMPNS_OLD = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_OLD 35
     * }
     */
    public static int SO_TIMESTAMPNS_OLD() {
        return SO_TIMESTAMPNS_OLD;
    }
    private static final int SO_TIMESTAMPING_OLD = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_OLD 37
     * }
     */
    public static int SO_TIMESTAMPING_OLD() {
        return SO_TIMESTAMPING_OLD;
    }
    private static final int SO_TIMESTAMP_NEW = (int)63L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_NEW 63
     * }
     */
    public static int SO_TIMESTAMP_NEW() {
        return SO_TIMESTAMP_NEW;
    }
    private static final int SO_TIMESTAMPNS_NEW = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_NEW 64
     * }
     */
    public static int SO_TIMESTAMPNS_NEW() {
        return SO_TIMESTAMPNS_NEW;
    }
    private static final int SO_TIMESTAMPING_NEW = (int)65L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_NEW 65
     * }
     */
    public static int SO_TIMESTAMPING_NEW() {
        return SO_TIMESTAMPING_NEW;
    }
    private static final int SO_RCVTIMEO_NEW = (int)66L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_NEW 66
     * }
     */
    public static int SO_RCVTIMEO_NEW() {
        return SO_RCVTIMEO_NEW;
    }
    private static final int SO_SNDTIMEO_NEW = (int)67L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_NEW 67
     * }
     */
    public static int SO_SNDTIMEO_NEW() {
        return SO_SNDTIMEO_NEW;
    }
    private static final int SO_DETACH_REUSEPORT_BPF = (int)68L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_REUSEPORT_BPF 68
     * }
     */
    public static int SO_DETACH_REUSEPORT_BPF() {
        return SO_DETACH_REUSEPORT_BPF;
    }
    private static final int SO_PREFER_BUSY_POLL = (int)69L;
    /**
     * {@snippet lang=c :
     * #define SO_PREFER_BUSY_POLL 69
     * }
     */
    public static int SO_PREFER_BUSY_POLL() {
        return SO_PREFER_BUSY_POLL;
    }
    private static final int SO_BUSY_POLL_BUDGET = (int)70L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL_BUDGET 70
     * }
     */
    public static int SO_BUSY_POLL_BUDGET() {
        return SO_BUSY_POLL_BUDGET;
    }
    private static final int SO_NETNS_COOKIE = (int)71L;
    /**
     * {@snippet lang=c :
     * #define SO_NETNS_COOKIE 71
     * }
     */
    public static int SO_NETNS_COOKIE() {
        return SO_NETNS_COOKIE;
    }
    private static final int SO_BUF_LOCK = (int)72L;
    /**
     * {@snippet lang=c :
     * #define SO_BUF_LOCK 72
     * }
     */
    public static int SO_BUF_LOCK() {
        return SO_BUF_LOCK;
    }
    private static final int SO_RESERVE_MEM = (int)73L;
    /**
     * {@snippet lang=c :
     * #define SO_RESERVE_MEM 73
     * }
     */
    public static int SO_RESERVE_MEM() {
        return SO_RESERVE_MEM;
    }
    private static final int SO_TXREHASH = (int)74L;
    /**
     * {@snippet lang=c :
     * #define SO_TXREHASH 74
     * }
     */
    public static int SO_TXREHASH() {
        return SO_TXREHASH;
    }
    private static final int SO_RCVMARK = (int)75L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVMARK 75
     * }
     */
    public static int SO_RCVMARK() {
        return SO_RCVMARK;
    }
    private static final int SO_PASSPIDFD = (int)76L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSPIDFD 76
     * }
     */
    public static int SO_PASSPIDFD() {
        return SO_PASSPIDFD;
    }
    private static final int SO_PEERPIDFD = (int)77L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERPIDFD 77
     * }
     */
    public static int SO_PEERPIDFD() {
        return SO_PEERPIDFD;
    }
    private static final int __osockaddr_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __osockaddr_defined 1
     * }
     */
    public static int __osockaddr_defined() {
        return __osockaddr_defined;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C23 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C23() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C23;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C23;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int __cookie_io_functions_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __cookie_io_functions_t_defined 1
     * }
     */
    public static int __cookie_io_functions_t_defined() {
        return __cookie_io_functions_t_defined;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int _LIBC_LIMITS_H_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _LIBC_LIMITS_H_ 1
     * }
     */
    public static int _LIBC_LIMITS_H_() {
        return _LIBC_LIMITS_H_;
    }
    private static final int MB_LEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 16
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int _BITS_POSIX1_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX1_LIM_H 1
     * }
     */
    public static int _BITS_POSIX1_LIM_H() {
        return _BITS_POSIX1_LIM_H;
    }
    private static final int _POSIX_AIO_LISTIO_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_LISTIO_MAX 2
     * }
     */
    public static int _POSIX_AIO_LISTIO_MAX() {
        return _POSIX_AIO_LISTIO_MAX;
    }
    private static final int _POSIX_AIO_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_MAX 1
     * }
     */
    public static int _POSIX_AIO_MAX() {
        return _POSIX_AIO_MAX;
    }
    private static final int _POSIX_ARG_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ARG_MAX 4096
     * }
     */
    public static int _POSIX_ARG_MAX() {
        return _POSIX_ARG_MAX;
    }
    private static final int _POSIX_CHILD_MAX = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHILD_MAX 25
     * }
     */
    public static int _POSIX_CHILD_MAX() {
        return _POSIX_CHILD_MAX;
    }
    private static final int _POSIX_DELAYTIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_DELAYTIMER_MAX 32
     * }
     */
    public static int _POSIX_DELAYTIMER_MAX() {
        return _POSIX_DELAYTIMER_MAX;
    }
    private static final int _POSIX_HOST_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_HOST_NAME_MAX 255
     * }
     */
    public static int _POSIX_HOST_NAME_MAX() {
        return _POSIX_HOST_NAME_MAX;
    }
    private static final int _POSIX_LINK_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LINK_MAX 8
     * }
     */
    public static int _POSIX_LINK_MAX() {
        return _POSIX_LINK_MAX;
    }
    private static final int _POSIX_LOGIN_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LOGIN_NAME_MAX 9
     * }
     */
    public static int _POSIX_LOGIN_NAME_MAX() {
        return _POSIX_LOGIN_NAME_MAX;
    }
    private static final int _POSIX_MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_CANON 255
     * }
     */
    public static int _POSIX_MAX_CANON() {
        return _POSIX_MAX_CANON;
    }
    private static final int _POSIX_MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_INPUT 255
     * }
     */
    public static int _POSIX_MAX_INPUT() {
        return _POSIX_MAX_INPUT;
    }
    private static final int _POSIX_MQ_OPEN_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_OPEN_MAX 8
     * }
     */
    public static int _POSIX_MQ_OPEN_MAX() {
        return _POSIX_MQ_OPEN_MAX;
    }
    private static final int _POSIX_MQ_PRIO_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_PRIO_MAX 32
     * }
     */
    public static int _POSIX_MQ_PRIO_MAX() {
        return _POSIX_MQ_PRIO_MAX;
    }
    private static final int _POSIX_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NAME_MAX 14
     * }
     */
    public static int _POSIX_NAME_MAX() {
        return _POSIX_NAME_MAX;
    }
    private static final int _POSIX_NGROUPS_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NGROUPS_MAX 8
     * }
     */
    public static int _POSIX_NGROUPS_MAX() {
        return _POSIX_NGROUPS_MAX;
    }
    private static final int _POSIX_OPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_OPEN_MAX 20
     * }
     */
    public static int _POSIX_OPEN_MAX() {
        return _POSIX_OPEN_MAX;
    }
    private static final int _POSIX_PATH_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PATH_MAX 256
     * }
     */
    public static int _POSIX_PATH_MAX() {
        return _POSIX_PATH_MAX;
    }
    private static final int _POSIX_PIPE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PIPE_BUF 512
     * }
     */
    public static int _POSIX_PIPE_BUF() {
        return _POSIX_PIPE_BUF;
    }
    private static final int _POSIX_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }
    private static final int _POSIX_RTSIG_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RTSIG_MAX 8
     * }
     */
    public static int _POSIX_RTSIG_MAX() {
        return _POSIX_RTSIG_MAX;
    }
    private static final int _POSIX_SEM_NSEMS_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_NSEMS_MAX 256
     * }
     */
    public static int _POSIX_SEM_NSEMS_MAX() {
        return _POSIX_SEM_NSEMS_MAX;
    }
    private static final int _POSIX_SEM_VALUE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_VALUE_MAX 32767
     * }
     */
    public static int _POSIX_SEM_VALUE_MAX() {
        return _POSIX_SEM_VALUE_MAX;
    }
    private static final int _POSIX_SIGQUEUE_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SIGQUEUE_MAX 32
     * }
     */
    public static int _POSIX_SIGQUEUE_MAX() {
        return _POSIX_SIGQUEUE_MAX;
    }
    private static final int _POSIX_SSIZE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SSIZE_MAX 32767
     * }
     */
    public static int _POSIX_SSIZE_MAX() {
        return _POSIX_SSIZE_MAX;
    }
    private static final int _POSIX_STREAM_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_STREAM_MAX 8
     * }
     */
    public static int _POSIX_STREAM_MAX() {
        return _POSIX_STREAM_MAX;
    }
    private static final int _POSIX_SYMLINK_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLINK_MAX 255
     * }
     */
    public static int _POSIX_SYMLINK_MAX() {
        return _POSIX_SYMLINK_MAX;
    }
    private static final int _POSIX_SYMLOOP_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLOOP_MAX 8
     * }
     */
    public static int _POSIX_SYMLOOP_MAX() {
        return _POSIX_SYMLOOP_MAX;
    }
    private static final int _POSIX_TIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMER_MAX 32
     * }
     */
    public static int _POSIX_TIMER_MAX() {
        return _POSIX_TIMER_MAX;
    }
    private static final int _POSIX_TTY_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TTY_NAME_MAX 9
     * }
     */
    public static int _POSIX_TTY_NAME_MAX() {
        return _POSIX_TTY_NAME_MAX;
    }
    private static final int _POSIX_TZNAME_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TZNAME_MAX 6
     * }
     */
    public static int _POSIX_TZNAME_MAX() {
        return _POSIX_TZNAME_MAX;
    }
    private static final int _POSIX_CLOCKRES_MIN = (int)20000000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCKRES_MIN 20000000
     * }
     */
    public static int _POSIX_CLOCKRES_MIN() {
        return _POSIX_CLOCKRES_MIN;
    }
    private static final int NR_OPEN = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define NR_OPEN 1024
     * }
     */
    public static int NR_OPEN() {
        return NR_OPEN;
    }
    private static final int NGROUPS_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS_MAX 65536
     * }
     */
    public static int NGROUPS_MAX() {
        return NGROUPS_MAX;
    }
    private static final int ARG_MAX = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 131072
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }
    private static final int LINK_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define LINK_MAX 127
     * }
     */
    public static int LINK_MAX() {
        return LINK_MAX;
    }
    private static final int MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CANON 255
     * }
     */
    public static int MAX_CANON() {
        return MAX_CANON;
    }
    private static final int MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_INPUT 255
     * }
     */
    public static int MAX_INPUT() {
        return MAX_INPUT;
    }
    private static final int NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define NAME_MAX 255
     * }
     */
    public static int NAME_MAX() {
        return NAME_MAX;
    }
    private static final int PATH_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PATH_MAX 4096
     * }
     */
    public static int PATH_MAX() {
        return PATH_MAX;
    }
    private static final int PIPE_BUF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PIPE_BUF 4096
     * }
     */
    public static int PIPE_BUF() {
        return PIPE_BUF;
    }
    private static final int XATTR_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define XATTR_NAME_MAX 255
     * }
     */
    public static int XATTR_NAME_MAX() {
        return XATTR_NAME_MAX;
    }
    private static final int XATTR_SIZE_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_SIZE_MAX 65536
     * }
     */
    public static int XATTR_SIZE_MAX() {
        return XATTR_SIZE_MAX;
    }
    private static final int XATTR_LIST_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_LIST_MAX 65536
     * }
     */
    public static int XATTR_LIST_MAX() {
        return XATTR_LIST_MAX;
    }
    private static final int RTSIG_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RTSIG_MAX 32
     * }
     */
    public static int RTSIG_MAX() {
        return RTSIG_MAX;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int PTHREAD_KEYS_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_KEYS_MAX 1024
     * }
     */
    public static int PTHREAD_KEYS_MAX() {
        return PTHREAD_KEYS_MAX;
    }
    private static final int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int _POSIX_THREAD_DESTRUCTOR_ITERATIONS() {
        return _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _POSIX_THREAD_THREADS_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_THREADS_MAX 64
     * }
     */
    public static int _POSIX_THREAD_THREADS_MAX() {
        return _POSIX_THREAD_THREADS_MAX;
    }
    private static final int AIO_PRIO_DELTA_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AIO_PRIO_DELTA_MAX 20
     * }
     */
    public static int AIO_PRIO_DELTA_MAX() {
        return AIO_PRIO_DELTA_MAX;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int DELAYTIMER_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define DELAYTIMER_MAX 2147483647
     * }
     */
    public static int DELAYTIMER_MAX() {
        return DELAYTIMER_MAX;
    }
    private static final int TTY_NAME_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define TTY_NAME_MAX 32
     * }
     */
    public static int TTY_NAME_MAX() {
        return TTY_NAME_MAX;
    }
    private static final int LOGIN_NAME_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define LOGIN_NAME_MAX 256
     * }
     */
    public static int LOGIN_NAME_MAX() {
        return LOGIN_NAME_MAX;
    }
    private static final int HOST_NAME_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define HOST_NAME_MAX 64
     * }
     */
    public static int HOST_NAME_MAX() {
        return HOST_NAME_MAX;
    }
    private static final int MQ_PRIO_MAX = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MQ_PRIO_MAX 32768
     * }
     */
    public static int MQ_PRIO_MAX() {
        return MQ_PRIO_MAX;
    }
    private static final int _BITS_POSIX2_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX2_LIM_H 1
     * }
     */
    public static int _BITS_POSIX2_LIM_H() {
        return _BITS_POSIX2_LIM_H;
    }
    private static final int _POSIX2_BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_BASE_MAX 99
     * }
     */
    public static int _POSIX2_BC_BASE_MAX() {
        return _POSIX2_BC_BASE_MAX;
    }
    private static final int _POSIX2_BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_DIM_MAX 2048
     * }
     */
    public static int _POSIX2_BC_DIM_MAX() {
        return _POSIX2_BC_DIM_MAX;
    }
    private static final int _POSIX2_BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_SCALE_MAX 99
     * }
     */
    public static int _POSIX2_BC_SCALE_MAX() {
        return _POSIX2_BC_SCALE_MAX;
    }
    private static final int _POSIX2_BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_STRING_MAX 1000
     * }
     */
    public static int _POSIX2_BC_STRING_MAX() {
        return _POSIX2_BC_STRING_MAX;
    }
    private static final int _POSIX2_COLL_WEIGHTS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_COLL_WEIGHTS_MAX 2
     * }
     */
    public static int _POSIX2_COLL_WEIGHTS_MAX() {
        return _POSIX2_COLL_WEIGHTS_MAX;
    }
    private static final int _POSIX2_EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_EXPR_NEST_MAX 32
     * }
     */
    public static int _POSIX2_EXPR_NEST_MAX() {
        return _POSIX2_EXPR_NEST_MAX;
    }
    private static final int _POSIX2_LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LINE_MAX 2048
     * }
     */
    public static int _POSIX2_LINE_MAX() {
        return _POSIX2_LINE_MAX;
    }
    private static final int _POSIX2_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX2_RE_DUP_MAX() {
        return _POSIX2_RE_DUP_MAX;
    }
    private static final int _POSIX2_CHARCLASS_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHARCLASS_NAME_MAX 14
     * }
     */
    public static int _POSIX2_CHARCLASS_NAME_MAX() {
        return _POSIX2_CHARCLASS_NAME_MAX;
    }
    private static final int COLL_WEIGHTS_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define COLL_WEIGHTS_MAX 255
     * }
     */
    public static int COLL_WEIGHTS_MAX() {
        return COLL_WEIGHTS_MAX;
    }
    private static final int CHARCLASS_NAME_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define CHARCLASS_NAME_MAX 2048
     * }
     */
    public static int CHARCLASS_NAME_MAX() {
        return CHARCLASS_NAME_MAX;
    }
    private static final int _TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _TIME_H 1
     * }
     */
    public static int _TIME_H() {
        return _TIME_H;
    }
    private static final int _BITS_TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME_H 1
     * }
     */
    public static int _BITS_TIME_H() {
        return _BITS_TIME_H;
    }
    private static final int CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }
    private static final int CLOCK_MONOTONIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 1
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }
    private static final int CLOCK_PROCESS_CPUTIME_ID = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 2
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int CLOCK_THREAD_CPUTIME_ID = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 3
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }
    private static final int CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }
    private static final int CLOCK_REALTIME_COARSE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_COARSE 5
     * }
     */
    public static int CLOCK_REALTIME_COARSE() {
        return CLOCK_REALTIME_COARSE;
    }
    private static final int CLOCK_MONOTONIC_COARSE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_COARSE 6
     * }
     */
    public static int CLOCK_MONOTONIC_COARSE() {
        return CLOCK_MONOTONIC_COARSE;
    }
    private static final int CLOCK_BOOTTIME = (int)7L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME 7
     * }
     */
    public static int CLOCK_BOOTTIME() {
        return CLOCK_BOOTTIME;
    }
    private static final int CLOCK_REALTIME_ALARM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_ALARM 8
     * }
     */
    public static int CLOCK_REALTIME_ALARM() {
        return CLOCK_REALTIME_ALARM;
    }
    private static final int CLOCK_BOOTTIME_ALARM = (int)9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME_ALARM 9
     * }
     */
    public static int CLOCK_BOOTTIME_ALARM() {
        return CLOCK_BOOTTIME_ALARM;
    }
    private static final int CLOCK_TAI = (int)11L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_TAI 11
     * }
     */
    public static int CLOCK_TAI() {
        return CLOCK_TAI;
    }
    private static final int TIMER_ABSTIME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIMER_ABSTIME 1
     * }
     */
    public static int TIMER_ABSTIME() {
        return TIMER_ABSTIME;
    }
    private static final int __struct_tm_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_tm_defined 1
     * }
     */
    public static int __struct_tm_defined() {
        return __struct_tm_defined;
    }
    private static final int __itimerspec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __itimerspec_defined 1
     * }
     */
    public static int __itimerspec_defined() {
        return __itimerspec_defined;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int _SYS_TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TIME_H 1
     * }
     */
    public static int _SYS_TIME_H() {
        return _SYS_TIME_H;
    }
    private static final int CURL_PROGRESSFUNC_CONTINUE = (int)268435457L;
    /**
     * {@snippet lang=c :
     * #define CURL_PROGRESSFUNC_CONTINUE 268435457
     * }
     */
    public static int CURL_PROGRESSFUNC_CONTINUE() {
        return CURL_PROGRESSFUNC_CONTINUE;
    }
    private static final int CURL_MAX_WRITE_SIZE = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define CURL_MAX_WRITE_SIZE 16384
     * }
     */
    public static int CURL_MAX_WRITE_SIZE() {
        return CURL_MAX_WRITE_SIZE;
    }
    private static final int CURL_WRITEFUNC_PAUSE = (int)268435457L;
    /**
     * {@snippet lang=c :
     * #define CURL_WRITEFUNC_PAUSE 268435457
     * }
     */
    public static int CURL_WRITEFUNC_PAUSE() {
        return CURL_WRITEFUNC_PAUSE;
    }
    private static final int CURL_CHUNK_BGN_FUNC_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_CHUNK_BGN_FUNC_OK 0
     * }
     */
    public static int CURL_CHUNK_BGN_FUNC_OK() {
        return CURL_CHUNK_BGN_FUNC_OK;
    }
    private static final int CURL_CHUNK_BGN_FUNC_FAIL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_CHUNK_BGN_FUNC_FAIL 1
     * }
     */
    public static int CURL_CHUNK_BGN_FUNC_FAIL() {
        return CURL_CHUNK_BGN_FUNC_FAIL;
    }
    private static final int CURL_CHUNK_BGN_FUNC_SKIP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_CHUNK_BGN_FUNC_SKIP 2
     * }
     */
    public static int CURL_CHUNK_BGN_FUNC_SKIP() {
        return CURL_CHUNK_BGN_FUNC_SKIP;
    }
    private static final int CURL_CHUNK_END_FUNC_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_CHUNK_END_FUNC_OK 0
     * }
     */
    public static int CURL_CHUNK_END_FUNC_OK() {
        return CURL_CHUNK_END_FUNC_OK;
    }
    private static final int CURL_CHUNK_END_FUNC_FAIL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_CHUNK_END_FUNC_FAIL 1
     * }
     */
    public static int CURL_CHUNK_END_FUNC_FAIL() {
        return CURL_CHUNK_END_FUNC_FAIL;
    }
    private static final int CURL_FNMATCHFUNC_MATCH = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_FNMATCHFUNC_MATCH 0
     * }
     */
    public static int CURL_FNMATCHFUNC_MATCH() {
        return CURL_FNMATCHFUNC_MATCH;
    }
    private static final int CURL_FNMATCHFUNC_NOMATCH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_FNMATCHFUNC_NOMATCH 1
     * }
     */
    public static int CURL_FNMATCHFUNC_NOMATCH() {
        return CURL_FNMATCHFUNC_NOMATCH;
    }
    private static final int CURL_FNMATCHFUNC_FAIL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_FNMATCHFUNC_FAIL 2
     * }
     */
    public static int CURL_FNMATCHFUNC_FAIL() {
        return CURL_FNMATCHFUNC_FAIL;
    }
    private static final int CURL_SEEKFUNC_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_SEEKFUNC_OK 0
     * }
     */
    public static int CURL_SEEKFUNC_OK() {
        return CURL_SEEKFUNC_OK;
    }
    private static final int CURL_SEEKFUNC_FAIL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_SEEKFUNC_FAIL 1
     * }
     */
    public static int CURL_SEEKFUNC_FAIL() {
        return CURL_SEEKFUNC_FAIL;
    }
    private static final int CURL_SEEKFUNC_CANTSEEK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_SEEKFUNC_CANTSEEK 2
     * }
     */
    public static int CURL_SEEKFUNC_CANTSEEK() {
        return CURL_SEEKFUNC_CANTSEEK;
    }
    private static final int CURL_READFUNC_ABORT = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define CURL_READFUNC_ABORT 268435456
     * }
     */
    public static int CURL_READFUNC_ABORT() {
        return CURL_READFUNC_ABORT;
    }
    private static final int CURL_READFUNC_PAUSE = (int)268435457L;
    /**
     * {@snippet lang=c :
     * #define CURL_READFUNC_PAUSE 268435457
     * }
     */
    public static int CURL_READFUNC_PAUSE() {
        return CURL_READFUNC_PAUSE;
    }
    private static final int CURL_TRAILERFUNC_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_TRAILERFUNC_OK 0
     * }
     */
    public static int CURL_TRAILERFUNC_OK() {
        return CURL_TRAILERFUNC_OK;
    }
    private static final int CURL_TRAILERFUNC_ABORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_TRAILERFUNC_ABORT 1
     * }
     */
    public static int CURL_TRAILERFUNC_ABORT() {
        return CURL_TRAILERFUNC_ABORT;
    }
    private static final int CURL_SOCKOPT_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_SOCKOPT_OK 0
     * }
     */
    public static int CURL_SOCKOPT_OK() {
        return CURL_SOCKOPT_OK;
    }
    private static final int CURL_SOCKOPT_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_SOCKOPT_ERROR 1
     * }
     */
    public static int CURL_SOCKOPT_ERROR() {
        return CURL_SOCKOPT_ERROR;
    }
    private static final int CURL_SOCKOPT_ALREADY_CONNECTED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_SOCKOPT_ALREADY_CONNECTED 2
     * }
     */
    public static int CURL_SOCKOPT_ALREADY_CONNECTED() {
        return CURL_SOCKOPT_ALREADY_CONNECTED;
    }
    private static final int CURL_PREREQFUNC_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_PREREQFUNC_OK 0
     * }
     */
    public static int CURL_PREREQFUNC_OK() {
        return CURL_PREREQFUNC_OK;
    }
    private static final int CURL_PREREQFUNC_ABORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_PREREQFUNC_ABORT 1
     * }
     */
    public static int CURL_PREREQFUNC_ABORT() {
        return CURL_PREREQFUNC_ABORT;
    }
    private static final int CURLE_ALREADY_COMPLETE = (int)99999L;
    /**
     * {@snippet lang=c :
     * #define CURLE_ALREADY_COMPLETE 99999
     * }
     */
    public static int CURLE_ALREADY_COMPLETE() {
        return CURLE_ALREADY_COMPLETE;
    }
    private static final int CURLOPT_OBSOLETE72 = (int)9999L;
    /**
     * {@snippet lang=c :
     * #define CURLOPT_OBSOLETE72 9999
     * }
     */
    public static int CURLOPT_OBSOLETE72() {
        return CURLOPT_OBSOLETE72;
    }
    private static final int CURLOPT_OBSOLETE40 = (int)9999L;
    /**
     * {@snippet lang=c :
     * #define CURLOPT_OBSOLETE40 9999
     * }
     */
    public static int CURLOPT_OBSOLETE40() {
        return CURLOPT_OBSOLETE40;
    }
    private static final int CURLSSH_AUTH_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURLSSH_AUTH_NONE 0
     * }
     */
    public static int CURLSSH_AUTH_NONE() {
        return CURLSSH_AUTH_NONE;
    }
    private static final int CURLGSSAPI_DELEGATION_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURLGSSAPI_DELEGATION_NONE 0
     * }
     */
    public static int CURLGSSAPI_DELEGATION_NONE() {
        return CURLGSSAPI_DELEGATION_NONE;
    }
    private static final int CURL_ERROR_SIZE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define CURL_ERROR_SIZE 256
     * }
     */
    public static int CURL_ERROR_SIZE() {
        return CURL_ERROR_SIZE;
    }
    private static final int CURLHEADER_UNIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURLHEADER_UNIFIED 0
     * }
     */
    public static int CURLHEADER_UNIFIED() {
        return CURLHEADER_UNIFIED;
    }
    private static final int CURLOPTTYPE_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURLOPTTYPE_LONG 0
     * }
     */
    public static int CURLOPTTYPE_LONG() {
        return CURLOPTTYPE_LONG;
    }
    private static final int CURLOPTTYPE_OBJECTPOINT = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define CURLOPTTYPE_OBJECTPOINT 10000
     * }
     */
    public static int CURLOPTTYPE_OBJECTPOINT() {
        return CURLOPTTYPE_OBJECTPOINT;
    }
    private static final int CURLOPTTYPE_FUNCTIONPOINT = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define CURLOPTTYPE_FUNCTIONPOINT 20000
     * }
     */
    public static int CURLOPTTYPE_FUNCTIONPOINT() {
        return CURLOPTTYPE_FUNCTIONPOINT;
    }
    private static final int CURLOPTTYPE_OFF_T = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define CURLOPTTYPE_OFF_T 30000
     * }
     */
    public static int CURLOPTTYPE_OFF_T() {
        return CURLOPTTYPE_OFF_T;
    }
    private static final int CURLOPTTYPE_BLOB = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define CURLOPTTYPE_BLOB 40000
     * }
     */
    public static int CURLOPTTYPE_BLOB() {
        return CURLOPTTYPE_BLOB;
    }
    private static final int CURL_IPRESOLVE_WHATEVER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_IPRESOLVE_WHATEVER 0
     * }
     */
    public static int CURL_IPRESOLVE_WHATEVER() {
        return CURL_IPRESOLVE_WHATEVER;
    }
    private static final int CURL_IPRESOLVE_V4 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_IPRESOLVE_V4 1
     * }
     */
    public static int CURL_IPRESOLVE_V4() {
        return CURL_IPRESOLVE_V4;
    }
    private static final int CURL_IPRESOLVE_V6 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_IPRESOLVE_V6 2
     * }
     */
    public static int CURL_IPRESOLVE_V6() {
        return CURL_IPRESOLVE_V6;
    }
    private static final int CURL_SSLVERSION_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_DEFAULT 0
     * }
     */
    public static int CURL_SSLVERSION_DEFAULT() {
        return CURL_SSLVERSION_DEFAULT;
    }
    private static final int CURL_SSLVERSION_TLSv1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_TLSv1 1
     * }
     */
    public static int CURL_SSLVERSION_TLSv1() {
        return CURL_SSLVERSION_TLSv1;
    }
    private static final int CURL_SSLVERSION_SSLv2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_SSLv2 2
     * }
     */
    public static int CURL_SSLVERSION_SSLv2() {
        return CURL_SSLVERSION_SSLv2;
    }
    private static final int CURL_SSLVERSION_SSLv3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_SSLv3 3
     * }
     */
    public static int CURL_SSLVERSION_SSLv3() {
        return CURL_SSLVERSION_SSLv3;
    }
    private static final int CURL_SSLVERSION_TLSv1_0 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_TLSv1_0 4
     * }
     */
    public static int CURL_SSLVERSION_TLSv1_0() {
        return CURL_SSLVERSION_TLSv1_0;
    }
    private static final int CURL_SSLVERSION_TLSv1_1 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_TLSv1_1 5
     * }
     */
    public static int CURL_SSLVERSION_TLSv1_1() {
        return CURL_SSLVERSION_TLSv1_1;
    }
    private static final int CURL_SSLVERSION_TLSv1_2 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_TLSv1_2 6
     * }
     */
    public static int CURL_SSLVERSION_TLSv1_2() {
        return CURL_SSLVERSION_TLSv1_2;
    }
    private static final int CURL_SSLVERSION_TLSv1_3 = (int)7L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_TLSv1_3 7
     * }
     */
    public static int CURL_SSLVERSION_TLSv1_3() {
        return CURL_SSLVERSION_TLSv1_3;
    }
    private static final int CURL_SSLVERSION_LAST = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_LAST 8
     * }
     */
    public static int CURL_SSLVERSION_LAST() {
        return CURL_SSLVERSION_LAST;
    }
    private static final int CURL_SSLVERSION_MAX_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_SSLVERSION_MAX_NONE 0
     * }
     */
    public static int CURL_SSLVERSION_MAX_NONE() {
        return CURL_SSLVERSION_MAX_NONE;
    }
    private static final int CURL_REDIR_GET_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_REDIR_GET_ALL 0
     * }
     */
    public static int CURL_REDIR_GET_ALL() {
        return CURL_REDIR_GET_ALL;
    }
    private static final int CURL_REDIR_POST_301 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_REDIR_POST_301 1
     * }
     */
    public static int CURL_REDIR_POST_301() {
        return CURL_REDIR_POST_301;
    }
    private static final int CURL_REDIR_POST_302 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_REDIR_POST_302 2
     * }
     */
    public static int CURL_REDIR_POST_302() {
        return CURL_REDIR_POST_302;
    }
    private static final int CURL_REDIR_POST_303 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CURL_REDIR_POST_303 4
     * }
     */
    public static int CURL_REDIR_POST_303() {
        return CURL_REDIR_POST_303;
    }
    private static final int CURLINFO_STRING = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_STRING 1048576
     * }
     */
    public static int CURLINFO_STRING() {
        return CURLINFO_STRING;
    }
    private static final int CURLINFO_LONG = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_LONG 2097152
     * }
     */
    public static int CURLINFO_LONG() {
        return CURLINFO_LONG;
    }
    private static final int CURLINFO_DOUBLE = (int)3145728L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_DOUBLE 3145728
     * }
     */
    public static int CURLINFO_DOUBLE() {
        return CURLINFO_DOUBLE;
    }
    private static final int CURLINFO_SLIST = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_SLIST 4194304
     * }
     */
    public static int CURLINFO_SLIST() {
        return CURLINFO_SLIST;
    }
    private static final int CURLINFO_PTR = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_PTR 4194304
     * }
     */
    public static int CURLINFO_PTR() {
        return CURLINFO_PTR;
    }
    private static final int CURLINFO_SOCKET = (int)5242880L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_SOCKET 5242880
     * }
     */
    public static int CURLINFO_SOCKET() {
        return CURLINFO_SOCKET;
    }
    private static final int CURLINFO_OFF_T = (int)6291456L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_OFF_T 6291456
     * }
     */
    public static int CURLINFO_OFF_T() {
        return CURLINFO_OFF_T;
    }
    private static final int CURLINFO_MASK = (int)1048575L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_MASK 1048575
     * }
     */
    public static int CURLINFO_MASK() {
        return CURLINFO_MASK;
    }
    private static final int CURLINFO_TYPEMASK = (int)15728640L;
    /**
     * {@snippet lang=c :
     * #define CURLINFO_TYPEMASK 15728640
     * }
     */
    public static int CURLINFO_TYPEMASK() {
        return CURLINFO_TYPEMASK;
    }
    private static final int CURL_GLOBAL_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_GLOBAL_NOTHING 0
     * }
     */
    public static int CURL_GLOBAL_NOTHING() {
        return CURL_GLOBAL_NOTHING;
    }
    private static final int CURL_BLOB_COPY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_BLOB_COPY 1
     * }
     */
    public static int CURL_BLOB_COPY() {
        return CURL_BLOB_COPY;
    }
    private static final int CURL_BLOB_NOCOPY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_BLOB_NOCOPY 0
     * }
     */
    public static int CURL_BLOB_NOCOPY() {
        return CURL_BLOB_NOCOPY;
    }
    private static final int CURL_WAIT_POLLIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_WAIT_POLLIN 1
     * }
     */
    public static int CURL_WAIT_POLLIN() {
        return CURL_WAIT_POLLIN;
    }
    private static final int CURL_WAIT_POLLPRI = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_WAIT_POLLPRI 2
     * }
     */
    public static int CURL_WAIT_POLLPRI() {
        return CURL_WAIT_POLLPRI;
    }
    private static final int CURL_WAIT_POLLOUT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CURL_WAIT_POLLOUT 4
     * }
     */
    public static int CURL_WAIT_POLLOUT() {
        return CURL_WAIT_POLLOUT;
    }
    private static final int CURL_POLL_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_POLL_NONE 0
     * }
     */
    public static int CURL_POLL_NONE() {
        return CURL_POLL_NONE;
    }
    private static final int CURL_POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_POLL_IN 1
     * }
     */
    public static int CURL_POLL_IN() {
        return CURL_POLL_IN;
    }
    private static final int CURL_POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_POLL_OUT 2
     * }
     */
    public static int CURL_POLL_OUT() {
        return CURL_POLL_OUT;
    }
    private static final int CURL_POLL_INOUT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CURL_POLL_INOUT 3
     * }
     */
    public static int CURL_POLL_INOUT() {
        return CURL_POLL_INOUT;
    }
    private static final int CURL_POLL_REMOVE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CURL_POLL_REMOVE 4
     * }
     */
    public static int CURL_POLL_REMOVE() {
        return CURL_POLL_REMOVE;
    }
    private static final int CURL_CSELECT_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_CSELECT_IN 1
     * }
     */
    public static int CURL_CSELECT_IN() {
        return CURL_CSELECT_IN;
    }
    private static final int CURL_CSELECT_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_CSELECT_OUT 2
     * }
     */
    public static int CURL_CSELECT_OUT() {
        return CURL_CSELECT_OUT;
    }
    private static final int CURL_CSELECT_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CURL_CSELECT_ERR 4
     * }
     */
    public static int CURL_CSELECT_ERR() {
        return CURL_CSELECT_ERR;
    }
    private static final int CURL_PUSH_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CURL_PUSH_OK 0
     * }
     */
    public static int CURL_PUSH_OK() {
        return CURL_PUSH_OK;
    }
    private static final int CURL_PUSH_DENY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CURL_PUSH_DENY 1
     * }
     */
    public static int CURL_PUSH_DENY() {
        return CURL_PUSH_DENY;
    }
    private static final int CURL_PUSH_ERROROUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CURL_PUSH_ERROROUT 2
     * }
     */
    public static int CURL_PUSH_ERROROUT() {
        return CURL_PUSH_ERROROUT;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = curl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = curl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = curl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = curl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = curl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = curl_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __socklen_t socklen_t
     * }
     */
    public static final OfInt socklen_t = curl_h.C_INT;
    private static final int SOCK_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_STREAM = 1
     * }
     */
    public static int SOCK_STREAM() {
        return SOCK_STREAM;
    }
    private static final int SOCK_DGRAM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DGRAM = 2
     * }
     */
    public static int SOCK_DGRAM() {
        return SOCK_DGRAM;
    }
    private static final int SOCK_RAW = (int)3L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RAW = 3
     * }
     */
    public static int SOCK_RAW() {
        return SOCK_RAW;
    }
    private static final int SOCK_RDM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RDM = 4
     * }
     */
    public static int SOCK_RDM() {
        return SOCK_RDM;
    }
    private static final int SOCK_SEQPACKET = (int)5L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_SEQPACKET = 5
     * }
     */
    public static int SOCK_SEQPACKET() {
        return SOCK_SEQPACKET;
    }
    private static final int SOCK_DCCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DCCP = 6
     * }
     */
    public static int SOCK_DCCP() {
        return SOCK_DCCP;
    }
    private static final int SOCK_PACKET = (int)10L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_PACKET = 10
     * }
     */
    public static int SOCK_PACKET() {
        return SOCK_PACKET;
    }
    private static final int SOCK_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_CLOEXEC = 524288
     * }
     */
    public static int SOCK_CLOEXEC() {
        return SOCK_CLOEXEC;
    }
    private static final int SOCK_NONBLOCK = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_NONBLOCK = 2048
     * }
     */
    public static int SOCK_NONBLOCK() {
        return SOCK_NONBLOCK;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short sa_family_t
     * }
     */
    public static final OfShort sa_family_t = curl_h.C_SHORT;
    private static final int MSG_OOB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_OOB = 1
     * }
     */
    public static int MSG_OOB() {
        return MSG_OOB;
    }
    private static final int MSG_PEEK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PEEK = 2
     * }
     */
    public static int MSG_PEEK() {
        return MSG_PEEK;
    }
    private static final int MSG_DONTROUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTROUTE = 4
     * }
     */
    public static int MSG_DONTROUTE() {
        return MSG_DONTROUTE;
    }
    private static final int MSG_CTRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CTRUNC = 8
     * }
     */
    public static int MSG_CTRUNC() {
        return MSG_CTRUNC;
    }
    private static final int MSG_PROXY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PROXY = 16
     * }
     */
    public static int MSG_PROXY() {
        return MSG_PROXY;
    }
    private static final int MSG_TRUNC = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_TRUNC = 32
     * }
     */
    public static int MSG_TRUNC() {
        return MSG_TRUNC;
    }
    private static final int MSG_DONTWAIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTWAIT = 64
     * }
     */
    public static int MSG_DONTWAIT() {
        return MSG_DONTWAIT;
    }
    private static final int MSG_EOR = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_EOR = 128
     * }
     */
    public static int MSG_EOR() {
        return MSG_EOR;
    }
    private static final int MSG_WAITALL = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITALL = 256
     * }
     */
    public static int MSG_WAITALL() {
        return MSG_WAITALL;
    }
    private static final int MSG_FIN = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FIN = 512
     * }
     */
    public static int MSG_FIN() {
        return MSG_FIN;
    }
    private static final int MSG_SYN = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_SYN = 1024
     * }
     */
    public static int MSG_SYN() {
        return MSG_SYN;
    }
    private static final int MSG_CONFIRM = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CONFIRM = 2048
     * }
     */
    public static int MSG_CONFIRM() {
        return MSG_CONFIRM;
    }
    private static final int MSG_RST = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_RST = 4096
     * }
     */
    public static int MSG_RST() {
        return MSG_RST;
    }
    private static final int MSG_ERRQUEUE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ERRQUEUE = 8192
     * }
     */
    public static int MSG_ERRQUEUE() {
        return MSG_ERRQUEUE;
    }
    private static final int MSG_NOSIGNAL = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_NOSIGNAL = 16384
     * }
     */
    public static int MSG_NOSIGNAL() {
        return MSG_NOSIGNAL;
    }
    private static final int MSG_MORE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_MORE = 32768
     * }
     */
    public static int MSG_MORE() {
        return MSG_MORE;
    }
    private static final int MSG_WAITFORONE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITFORONE = 65536
     * }
     */
    public static int MSG_WAITFORONE() {
        return MSG_WAITFORONE;
    }
    private static final int MSG_BATCH = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_BATCH = 262144
     * }
     */
    public static int MSG_BATCH() {
        return MSG_BATCH;
    }
    private static final int MSG_ZEROCOPY = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ZEROCOPY = 67108864
     * }
     */
    public static int MSG_ZEROCOPY() {
        return MSG_ZEROCOPY;
    }
    private static final int MSG_FASTOPEN = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FASTOPEN = 536870912
     * }
     */
    public static int MSG_FASTOPEN() {
        return MSG_FASTOPEN;
    }
    private static final int MSG_CMSG_CLOEXEC = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CMSG_CLOEXEC = 1073741824
     * }
     */
    public static int MSG_CMSG_CLOEXEC() {
        return MSG_CMSG_CLOEXEC;
    }

    private static class __cmsg_nxthdr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("__cmsg_nxthdr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static FunctionDescriptor __cmsg_nxthdr$descriptor() {
        return __cmsg_nxthdr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MethodHandle __cmsg_nxthdr$handle() {
        return __cmsg_nxthdr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr$address() {
        return __cmsg_nxthdr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr(MemorySegment __mhdr, MemorySegment __cmsg) {
        var mh$ = __cmsg_nxthdr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cmsg_nxthdr", __mhdr, __cmsg);
            }
            return (MemorySegment)mh$.invokeExact(__mhdr, __cmsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCM_RIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCM_RIGHTS = 1
     * }
     */
    public static int SCM_RIGHTS() {
        return SCM_RIGHTS;
    }
    /**
     * {@snippet lang=c :
     * typedef int __kernel_key_t
     * }
     */
    public static final OfInt __kernel_key_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_mqd_t
     * }
     */
    public static final OfInt __kernel_mqd_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_uid_t
     * }
     */
    public static final OfShort __kernel_old_uid_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_gid_t
     * }
     */
    public static final OfShort __kernel_old_gid_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_old_dev_t
     * }
     */
    public static final OfLong __kernel_old_dev_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __kernel_long_t
     * }
     */
    public static final OfLong __kernel_long_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_ulong_t
     * }
     */
    public static final OfLong __kernel_ulong_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_ino_t
     * }
     */
    public static final OfLong __kernel_ino_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_mode_t
     * }
     */
    public static final OfInt __kernel_mode_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_pid_t
     * }
     */
    public static final OfInt __kernel_pid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_ipc_pid_t
     * }
     */
    public static final OfInt __kernel_ipc_pid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid_t
     * }
     */
    public static final OfInt __kernel_uid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid_t
     * }
     */
    public static final OfInt __kernel_gid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_suseconds_t
     * }
     */
    public static final OfLong __kernel_suseconds_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_daddr_t
     * }
     */
    public static final OfInt __kernel_daddr_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid32_t
     * }
     */
    public static final OfInt __kernel_uid32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid32_t
     * }
     */
    public static final OfInt __kernel_gid32_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_size_t
     * }
     */
    public static final OfLong __kernel_size_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ssize_t
     * }
     */
    public static final OfLong __kernel_ssize_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ptrdiff_t
     * }
     */
    public static final OfLong __kernel_ptrdiff_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_off_t
     * }
     */
    public static final OfLong __kernel_off_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_loff_t
     * }
     */
    public static final OfLong __kernel_loff_t = curl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_old_time_t
     * }
     */
    public static final OfLong __kernel_old_time_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_time_t
     * }
     */
    public static final OfLong __kernel_time_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_time64_t
     * }
     */
    public static final OfLong __kernel_time64_t = curl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_clock_t
     * }
     */
    public static final OfLong __kernel_clock_t = curl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_timer_t
     * }
     */
    public static final OfInt __kernel_timer_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_clockid_t
     * }
     */
    public static final OfInt __kernel_clockid_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *__kernel_caddr_t
     * }
     */
    public static final AddressLayout __kernel_caddr_t = curl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_uid16_t
     * }
     */
    public static final OfShort __kernel_uid16_t = curl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_gid16_t
     * }
     */
    public static final OfShort __kernel_gid16_t = curl_h.C_SHORT;
    private static final int SHUT_RD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RD = 0
     * }
     */
    public static int SHUT_RD() {
        return SHUT_RD;
    }
    private static final int SHUT_WR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_WR = 1
     * }
     */
    public static int SHUT_WR() {
        return SHUT_WR;
    }
    private static final int SHUT_RDWR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RDWR = 2
     * }
     */
    public static int SHUT_RDWR() {
        return SHUT_RDWR;
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static int socket(int __domain, int __type, int __protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", __domain, __type, __protocol);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socketpair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("socketpair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static FunctionDescriptor socketpair$descriptor() {
        return socketpair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MethodHandle socketpair$handle() {
        return socketpair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MemorySegment socketpair$address() {
        return socketpair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static int socketpair(int __domain, int __type, int __protocol, MemorySegment __fds) {
        var mh$ = socketpair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socketpair", __domain, __type, __protocol, __fds);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol, __fds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int bind(int __fd, MemorySegment __addr, int __len) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getsockname(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int connect(int __fd, MemorySegment __addr, int __len) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getpeername(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static long send(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static long recv(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static long sendto(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, int __addr_len) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static long recvfrom(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor sendmsg$descriptor() {
        return sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle sendmsg$handle() {
        return sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment sendmsg$address() {
        return sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static long sendmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor recvmsg$descriptor() {
        return recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle recvmsg$handle() {
        return recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment recvmsg$address() {
        return recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static long recvmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static int getsockopt(int __fd, int __level, int __optname, MemorySegment __optval, MemorySegment __optlen) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static int setsockopt(int __fd, int __level, int __optname, MemorySegment __optval, int __optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static int listen(int __fd, int __n) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", __fd, __n);
            }
            return (int)mh$.invokeExact(__fd, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static int accept(int __fd, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", __fd, __addr, __addr_len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static int shutdown(int __fd, int __how) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", __fd, __how);
            }
            return (int)mh$.invokeExact(__fd, __how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sockatmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("sockatmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static FunctionDescriptor sockatmark$descriptor() {
        return sockatmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MethodHandle sockatmark$handle() {
        return sockatmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MemorySegment sockatmark$address() {
        return sockatmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static int sockatmark(int __fd) {
        var mh$ = sockatmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sockatmark", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isfdtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("isfdtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static FunctionDescriptor isfdtype$descriptor() {
        return isfdtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MethodHandle isfdtype$handle() {
        return isfdtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MemorySegment isfdtype$address() {
        return isfdtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static int isfdtype(int __fd, int __fdtype) {
        var mh$ = isfdtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isfdtype", __fd, __fdtype);
            }
            return (int)mh$.invokeExact(__fd, __fdtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef socklen_t curl_socklen_t
     * }
     */
    public static final OfInt curl_socklen_t = curl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long curl_off_t
     * }
     */
    public static final OfLong curl_off_t = curl_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = curl_h.C_POINTER;
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = curl_h.C_POINTER;
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = curl_h.C_POINTER;
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER    );

        public static final MemorySegment ADDR = curl_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fopencookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie$address() {
        return fopencookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_INT,
            curl_h.C_LONG
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_LONG
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER,
                curl_h.C_LONG,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int)spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int)spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int)spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_INT,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int)spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                curl_h.C_INT,
                curl_h.C_POINTER,
                curl_h.C_POINTER
            );
        private static final MemorySegment ADDR = curl_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = curl_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = curl_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = curl_h.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT    );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT    );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = curl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = curl_h.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG    );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_DOUBLE,
            curl_h.C_LONG,
            curl_h.C_LONG
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_LONG,
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_POINTER,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, curl_h.C_POINTER);
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = curl_h.C_INT;
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = curl_h.C_LONG;
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, curl_h.C_POINTER);
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = curl_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = curl_h.C_INT;
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = curl_h.C_LONG;
        public static final MemorySegment SEGMENT = curl_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_LONG,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_INT
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gettimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("gettimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static FunctionDescriptor gettimeofday$descriptor() {
        return gettimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static MethodHandle gettimeofday$handle() {
        return gettimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static MemorySegment gettimeofday$address() {
        return gettimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gettimeofday(struct timeval *restrict __tv, void *restrict __tz)
     * }
     */
    public static int gettimeofday(MemorySegment __tv, MemorySegment __tz) {
        var mh$ = gettimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gettimeofday", __tv, __tz);
            }
            return (int)mh$.invokeExact(__tv, __tz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("settimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static FunctionDescriptor settimeofday$descriptor() {
        return settimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static MethodHandle settimeofday$handle() {
        return settimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static MemorySegment settimeofday$address() {
        return settimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int settimeofday(const struct timeval *__tv, const struct timezone *__tz)
     * }
     */
    public static int settimeofday(MemorySegment __tv, MemorySegment __tz) {
        var mh$ = settimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settimeofday", __tv, __tz);
            }
            return (int)mh$.invokeExact(__tv, __tz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class adjtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("adjtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static FunctionDescriptor adjtime$descriptor() {
        return adjtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static MethodHandle adjtime$handle() {
        return adjtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static MemorySegment adjtime$address() {
        return adjtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int adjtime(const struct timeval *__delta, struct timeval *__olddelta)
     * }
     */
    public static int adjtime(MemorySegment __delta, MemorySegment __olddelta) {
        var mh$ = adjtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtime", __delta, __olddelta);
            }
            return (int)mh$.invokeExact(__delta, __olddelta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ITIMER_REAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_REAL = 0
     * }
     */
    public static int ITIMER_REAL() {
        return ITIMER_REAL;
    }
    private static final int ITIMER_VIRTUAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_VIRTUAL = 1
     * }
     */
    public static int ITIMER_VIRTUAL() {
        return ITIMER_VIRTUAL;
    }
    private static final int ITIMER_PROF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __itimer_which.ITIMER_PROF = 2
     * }
     */
    public static int ITIMER_PROF() {
        return ITIMER_PROF;
    }
    /**
     * {@snippet lang=c :
     * typedef int __itimer_which_t
     * }
     */
    public static final OfInt __itimer_which_t = curl_h.C_INT;

    private static class getitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("getitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static FunctionDescriptor getitimer$descriptor() {
        return getitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static MethodHandle getitimer$handle() {
        return getitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static MemorySegment getitimer$address() {
        return getitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getitimer(__itimer_which_t __which, struct itimerval *__value)
     * }
     */
    public static int getitimer(int __which, MemorySegment __value) {
        var mh$ = getitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getitimer", __which, __value);
            }
            return (int)mh$.invokeExact(__which, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("setitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static FunctionDescriptor setitimer$descriptor() {
        return setitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static MethodHandle setitimer$handle() {
        return setitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static MemorySegment setitimer$address() {
        return setitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setitimer(__itimer_which_t __which, const struct itimerval *restrict __new, struct itimerval *restrict __old)
     * }
     */
    public static int setitimer(int __which, MemorySegment __new, MemorySegment __old) {
        var mh$ = setitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setitimer", __which, __new, __old);
            }
            return (int)mh$.invokeExact(__which, __new, __old);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("utimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor utimes$descriptor() {
        return utimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle utimes$handle() {
        return utimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment utimes$address() {
        return utimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int utimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static int utimes(MemorySegment __file, MemorySegment __tvp) {
        var mh$ = utimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimes", __file, __tvp);
            }
            return (int)mh$.invokeExact(__file, __tvp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lutimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_POINTER,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("lutimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor lutimes$descriptor() {
        return lutimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle lutimes$handle() {
        return lutimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment lutimes$address() {
        return lutimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lutimes(const char *__file, const struct timeval __tvp[2])
     * }
     */
    public static int lutimes(MemorySegment __file, MemorySegment __tvp) {
        var mh$ = lutimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lutimes", __file, __tvp);
            }
            return (int)mh$.invokeExact(__file, __tvp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            curl_h.C_INT,
            curl_h.C_INT,
            curl_h.C_POINTER
        );

        public static final MemorySegment ADDR = curl_h.findOrThrow("futimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static FunctionDescriptor futimes$descriptor() {
        return futimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static MethodHandle futimes$handle() {
        return futimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static MemorySegment futimes$address() {
        return futimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int futimes(int __fd, const struct timeval __tvp[2])
     * }
     */
    public static int futimes(int __fd, MemorySegment __tvp) {
        var mh$ = futimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimes", __fd, __tvp);
            }
            return (int)mh$.invokeExact(__fd, __tvp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int curl_socket_t
     * }
     */
    public static final OfInt curl_socket_t = curl_h.C_INT;
    private static final int CURLSSLBACKEND_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_NONE = 0
     * }
     */
    public static int CURLSSLBACKEND_NONE() {
        return CURLSSLBACKEND_NONE;
    }
    private static final int CURLSSLBACKEND_OPENSSL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_OPENSSL = 1
     * }
     */
    public static int CURLSSLBACKEND_OPENSSL() {
        return CURLSSLBACKEND_OPENSSL;
    }
    private static final int CURLSSLBACKEND_GNUTLS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_GNUTLS = 2
     * }
     */
    public static int CURLSSLBACKEND_GNUTLS() {
        return CURLSSLBACKEND_GNUTLS;
    }
    private static final int CURLSSLBACKEND_NSS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_NSS = 3
     * }
     */
    public static int CURLSSLBACKEND_NSS() {
        return CURLSSLBACKEND_NSS;
    }
    private static final int CURLSSLBACKEND_OBSOLETE4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_OBSOLETE4 = 4
     * }
     */
    public static int CURLSSLBACKEND_OBSOLETE4() {
        return CURLSSLBACKEND_OBSOLETE4;
    }
    private static final int CURLSSLBACKEND_GSKIT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_GSKIT = 5
     * }
     */
    public static int CURLSSLBACKEND_GSKIT() {
        return CURLSSLBACKEND_GSKIT;
    }
    private static final int CURLSSLBACKEND_POLARSSL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_POLARSSL = 6
     * }
     */
    public static int CURLSSLBACKEND_POLARSSL() {
        return CURLSSLBACKEND_POLARSSL;
    }
    private static final int CURLSSLBACKEND_WOLFSSL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_WOLFSSL = 7
     * }
     */
    public static int CURLSSLBACKEND_WOLFSSL() {
        return CURLSSLBACKEND_WOLFSSL;
    }
    private static final int CURLSSLBACKEND_SCHANNEL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_SCHANNEL = 8
     * }
     */
    public static int CURLSSLBACKEND_SCHANNEL() {
        return CURLSSLBACKEND_SCHANNEL;
    }
    private static final int CURLSSLBACKEND_SECURETRANSPORT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_SECURETRANSPORT = 9
     * }
     */
    public static int CURLSSLBACKEND_SECURETRANSPORT() {
        return CURLSSLBACKEND_SECURETRANSPORT;
    }
    private static final int CURLSSLBACKEND_AXTLS = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_AXTLS = 10
     * }
     */
    public static int CURLSSLBACKEND_AXTLS() {
        return CURLSSLBACKEND_AXTLS;
    }
    private static final int CURLSSLBACKEND_MBEDTLS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_MBEDTLS = 11
     * }
     */
    public static int CURLSSLBACKEND_MBEDTLS() {
        return CURLSSLBACKEND_MBEDTLS;
    }
    private static final int CURLSSLBACKEND_MESALINK = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_MESALINK = 12
     * }
     */
    public static int CURLSSLBACKEND_MESALINK() {
        return CURLSSLBACKEND_MESALINK;
    }
    private static final int CURLSSLBACKEND_BEARSSL = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_BEARSSL = 13
     * }
     */
    public static int CURLSSLBACKEND_BEARSSL() {
        return CURLSSLBACKEND_BEARSSL;
    }
    private static final int CURLSSLBACKEND_RUSTLS = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSSLBACKEND_RUSTLS = 14
     * }
     */
    public static int CURLSSLBACKEND_RUSTLS() {
        return CURLSSLBACKEND_RUSTLS;
    }
    private static final int CURLFILETYPE_FILE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_FILE = 0
     * }
     */
    public static int CURLFILETYPE_FILE() {
        return CURLFILETYPE_FILE;
    }
    private static final int CURLFILETYPE_DIRECTORY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_DIRECTORY = 1
     * }
     */
    public static int CURLFILETYPE_DIRECTORY() {
        return CURLFILETYPE_DIRECTORY;
    }
    private static final int CURLFILETYPE_SYMLINK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_SYMLINK = 2
     * }
     */
    public static int CURLFILETYPE_SYMLINK() {
        return CURLFILETYPE_SYMLINK;
    }
    private static final int CURLFILETYPE_DEVICE_BLOCK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_DEVICE_BLOCK = 3
     * }
     */
    public static int CURLFILETYPE_DEVICE_BLOCK() {
        return CURLFILETYPE_DEVICE_BLOCK;
    }
    private static final int CURLFILETYPE_DEVICE_CHAR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_DEVICE_CHAR = 4
     * }
     */
    public static int CURLFILETYPE_DEVICE_CHAR() {
        return CURLFILETYPE_DEVICE_CHAR;
    }
    private static final int CURLFILETYPE_NAMEDPIPE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_NAMEDPIPE = 5
     * }
     */
    public static int CURLFILETYPE_NAMEDPIPE() {
        return CURLFILETYPE_NAMEDPIPE;
    }
    private static final int CURLFILETYPE_SOCKET = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_SOCKET = 6
     * }
     */
    public static int CURLFILETYPE_SOCKET() {
        return CURLFILETYPE_SOCKET;
    }
    private static final int CURLFILETYPE_DOOR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_DOOR = 7
     * }
     */
    public static int CURLFILETYPE_DOOR() {
        return CURLFILETYPE_DOOR;
    }
    private static final int CURLFILETYPE_UNKNOWN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLFILETYPE_UNKNOWN = 8
     * }
     */
    public static int CURLFILETYPE_UNKNOWN() {
        return CURLFILETYPE_UNKNOWN;
    }
    private static final int CURLSOCKTYPE_IPCXN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSOCKTYPE_IPCXN = 0
     * }
     */
    public static int CURLSOCKTYPE_IPCXN() {
        return CURLSOCKTYPE_IPCXN;
    }
    private static final int CURLSOCKTYPE_ACCEPT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSOCKTYPE_ACCEPT = 1
     * }
     */
    public static int CURLSOCKTYPE_ACCEPT() {
        return CURLSOCKTYPE_ACCEPT;
    }
    private static final int CURLSOCKTYPE_LAST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLSOCKTYPE_LAST = 2
     * }
     */
    public static int CURLSOCKTYPE_LAST() {
        return CURLSOCKTYPE_LAST;
    }
    private static final int CURLIOE_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLIOE_OK = 0
     * }
     */
    public static int CURLIOE_OK() {
        return CURLIOE_OK;
    }
    private static final int CURLIOE_UNKNOWNCMD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLIOE_UNKNOWNCMD = 1
     * }
     */
    public static int CURLIOE_UNKNOWNCMD() {
        return CURLIOE_UNKNOWNCMD;
    }
    private static final int CURLIOE_FAILRESTART = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLIOE_FAILRESTART = 2
     * }
     */
    public static int CURLIOE_FAILRESTART() {
        return CURLIOE_FAILRESTART;
    }
    private static final int CURLIOE_LAST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLIOE_LAST = 3
     * }
     */
    public static int CURLIOE_LAST() {
        return CURLIOE_LAST;
    }
    private static final int CURLIOCMD_NOP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLIOCMD_NOP = 0
     * }
     */
    public static int CURLIOCMD_NOP() {
        return CURLIOCMD_NOP;
    }
    private static final int CURLIOCMD_RESTARTREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLIOCMD_RESTARTREAD = 1
     * }
     */
    public static int CURLIOCMD_RESTARTREAD() {
        return CURLIOCMD_RESTARTREAD;
    }
    private static final int CURLIOCMD_LAST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLIOCMD_LAST = 2
     * }
     */
    public static int CURLIOCMD_LAST() {
        return CURLIOCMD_LAST;
    }
    private static final int CURLINFO_TEXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_TEXT = 0
     * }
     */
    public static int CURLINFO_TEXT() {
        return CURLINFO_TEXT;
    }
    private static final int CURLINFO_HEADER_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_HEADER_IN = 1
     * }
     */
    public static int CURLINFO_HEADER_IN() {
        return CURLINFO_HEADER_IN;
    }
    private static final int CURLINFO_HEADER_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_HEADER_OUT = 2
     * }
     */
    public static int CURLINFO_HEADER_OUT() {
        return CURLINFO_HEADER_OUT;
    }
    private static final int CURLINFO_DATA_IN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_DATA_IN = 3
     * }
     */
    public static int CURLINFO_DATA_IN() {
        return CURLINFO_DATA_IN;
    }
    private static final int CURLINFO_DATA_OUT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_DATA_OUT = 4
     * }
     */
    public static int CURLINFO_DATA_OUT() {
        return CURLINFO_DATA_OUT;
    }
    private static final int CURLINFO_SSL_DATA_IN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_SSL_DATA_IN = 5
     * }
     */
    public static int CURLINFO_SSL_DATA_IN() {
        return CURLINFO_SSL_DATA_IN;
    }
    private static final int CURLINFO_SSL_DATA_OUT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_SSL_DATA_OUT = 6
     * }
     */
    public static int CURLINFO_SSL_DATA_OUT() {
        return CURLINFO_SSL_DATA_OUT;
    }
    private static final int CURLINFO_END = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLINFO_END = 7
     * }
     */
    public static int CURLINFO_END() {
        return CURLINFO_END;
    }
    private static final int CURLE_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OK = 0
     * }
     */
    public static int CURLE_OK() {
        return CURLE_OK;
    }
    private static final int CURLE_UNSUPPORTED_PROTOCOL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_UNSUPPORTED_PROTOCOL = 1
     * }
     */
    public static int CURLE_UNSUPPORTED_PROTOCOL() {
        return CURLE_UNSUPPORTED_PROTOCOL;
    }
    private static final int CURLE_FAILED_INIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FAILED_INIT = 2
     * }
     */
    public static int CURLE_FAILED_INIT() {
        return CURLE_FAILED_INIT;
    }
    private static final int CURLE_URL_MALFORMAT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_URL_MALFORMAT = 3
     * }
     */
    public static int CURLE_URL_MALFORMAT() {
        return CURLE_URL_MALFORMAT;
    }
    private static final int CURLE_NOT_BUILT_IN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_NOT_BUILT_IN = 4
     * }
     */
    public static int CURLE_NOT_BUILT_IN() {
        return CURLE_NOT_BUILT_IN;
    }
    private static final int CURLE_COULDNT_RESOLVE_PROXY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_COULDNT_RESOLVE_PROXY = 5
     * }
     */
    public static int CURLE_COULDNT_RESOLVE_PROXY() {
        return CURLE_COULDNT_RESOLVE_PROXY;
    }
    private static final int CURLE_COULDNT_RESOLVE_HOST = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_COULDNT_RESOLVE_HOST = 6
     * }
     */
    public static int CURLE_COULDNT_RESOLVE_HOST() {
        return CURLE_COULDNT_RESOLVE_HOST;
    }
    private static final int CURLE_COULDNT_CONNECT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_COULDNT_CONNECT = 7
     * }
     */
    public static int CURLE_COULDNT_CONNECT() {
        return CURLE_COULDNT_CONNECT;
    }
    private static final int CURLE_WEIRD_SERVER_REPLY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_WEIRD_SERVER_REPLY = 8
     * }
     */
    public static int CURLE_WEIRD_SERVER_REPLY() {
        return CURLE_WEIRD_SERVER_REPLY;
    }
    private static final int CURLE_REMOTE_ACCESS_DENIED = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_REMOTE_ACCESS_DENIED = 9
     * }
     */
    public static int CURLE_REMOTE_ACCESS_DENIED() {
        return CURLE_REMOTE_ACCESS_DENIED;
    }
    private static final int CURLE_FTP_ACCEPT_FAILED = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_ACCEPT_FAILED = 10
     * }
     */
    public static int CURLE_FTP_ACCEPT_FAILED() {
        return CURLE_FTP_ACCEPT_FAILED;
    }
    private static final int CURLE_FTP_WEIRD_PASS_REPLY = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_WEIRD_PASS_REPLY = 11
     * }
     */
    public static int CURLE_FTP_WEIRD_PASS_REPLY() {
        return CURLE_FTP_WEIRD_PASS_REPLY;
    }
    private static final int CURLE_FTP_ACCEPT_TIMEOUT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_ACCEPT_TIMEOUT = 12
     * }
     */
    public static int CURLE_FTP_ACCEPT_TIMEOUT() {
        return CURLE_FTP_ACCEPT_TIMEOUT;
    }
    private static final int CURLE_FTP_WEIRD_PASV_REPLY = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_WEIRD_PASV_REPLY = 13
     * }
     */
    public static int CURLE_FTP_WEIRD_PASV_REPLY() {
        return CURLE_FTP_WEIRD_PASV_REPLY;
    }
    private static final int CURLE_FTP_WEIRD_227_FORMAT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_WEIRD_227_FORMAT = 14
     * }
     */
    public static int CURLE_FTP_WEIRD_227_FORMAT() {
        return CURLE_FTP_WEIRD_227_FORMAT;
    }
    private static final int CURLE_FTP_CANT_GET_HOST = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_CANT_GET_HOST = 15
     * }
     */
    public static int CURLE_FTP_CANT_GET_HOST() {
        return CURLE_FTP_CANT_GET_HOST;
    }
    private static final int CURLE_HTTP2 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_HTTP2 = 16
     * }
     */
    public static int CURLE_HTTP2() {
        return CURLE_HTTP2;
    }
    private static final int CURLE_FTP_COULDNT_SET_TYPE = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_COULDNT_SET_TYPE = 17
     * }
     */
    public static int CURLE_FTP_COULDNT_SET_TYPE() {
        return CURLE_FTP_COULDNT_SET_TYPE;
    }
    private static final int CURLE_PARTIAL_FILE = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_PARTIAL_FILE = 18
     * }
     */
    public static int CURLE_PARTIAL_FILE() {
        return CURLE_PARTIAL_FILE;
    }
    private static final int CURLE_FTP_COULDNT_RETR_FILE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_COULDNT_RETR_FILE = 19
     * }
     */
    public static int CURLE_FTP_COULDNT_RETR_FILE() {
        return CURLE_FTP_COULDNT_RETR_FILE;
    }
    private static final int CURLE_OBSOLETE20 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE20 = 20
     * }
     */
    public static int CURLE_OBSOLETE20() {
        return CURLE_OBSOLETE20;
    }
    private static final int CURLE_QUOTE_ERROR = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_QUOTE_ERROR = 21
     * }
     */
    public static int CURLE_QUOTE_ERROR() {
        return CURLE_QUOTE_ERROR;
    }
    private static final int CURLE_HTTP_RETURNED_ERROR = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_HTTP_RETURNED_ERROR = 22
     * }
     */
    public static int CURLE_HTTP_RETURNED_ERROR() {
        return CURLE_HTTP_RETURNED_ERROR;
    }
    private static final int CURLE_WRITE_ERROR = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_WRITE_ERROR = 23
     * }
     */
    public static int CURLE_WRITE_ERROR() {
        return CURLE_WRITE_ERROR;
    }
    private static final int CURLE_OBSOLETE24 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE24 = 24
     * }
     */
    public static int CURLE_OBSOLETE24() {
        return CURLE_OBSOLETE24;
    }
    private static final int CURLE_UPLOAD_FAILED = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_UPLOAD_FAILED = 25
     * }
     */
    public static int CURLE_UPLOAD_FAILED() {
        return CURLE_UPLOAD_FAILED;
    }
    private static final int CURLE_READ_ERROR = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_READ_ERROR = 26
     * }
     */
    public static int CURLE_READ_ERROR() {
        return CURLE_READ_ERROR;
    }
    private static final int CURLE_OUT_OF_MEMORY = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OUT_OF_MEMORY = 27
     * }
     */
    public static int CURLE_OUT_OF_MEMORY() {
        return CURLE_OUT_OF_MEMORY;
    }
    private static final int CURLE_OPERATION_TIMEDOUT = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OPERATION_TIMEDOUT = 28
     * }
     */
    public static int CURLE_OPERATION_TIMEDOUT() {
        return CURLE_OPERATION_TIMEDOUT;
    }
    private static final int CURLE_OBSOLETE29 = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE29 = 29
     * }
     */
    public static int CURLE_OBSOLETE29() {
        return CURLE_OBSOLETE29;
    }
    private static final int CURLE_FTP_PORT_FAILED = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_PORT_FAILED = 30
     * }
     */
    public static int CURLE_FTP_PORT_FAILED() {
        return CURLE_FTP_PORT_FAILED;
    }
    private static final int CURLE_FTP_COULDNT_USE_REST = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_COULDNT_USE_REST = 31
     * }
     */
    public static int CURLE_FTP_COULDNT_USE_REST() {
        return CURLE_FTP_COULDNT_USE_REST;
    }
    private static final int CURLE_OBSOLETE32 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE32 = 32
     * }
     */
    public static int CURLE_OBSOLETE32() {
        return CURLE_OBSOLETE32;
    }
    private static final int CURLE_RANGE_ERROR = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_RANGE_ERROR = 33
     * }
     */
    public static int CURLE_RANGE_ERROR() {
        return CURLE_RANGE_ERROR;
    }
    private static final int CURLE_HTTP_POST_ERROR = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_HTTP_POST_ERROR = 34
     * }
     */
    public static int CURLE_HTTP_POST_ERROR() {
        return CURLE_HTTP_POST_ERROR;
    }
    private static final int CURLE_SSL_CONNECT_ERROR = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_CONNECT_ERROR = 35
     * }
     */
    public static int CURLE_SSL_CONNECT_ERROR() {
        return CURLE_SSL_CONNECT_ERROR;
    }
    private static final int CURLE_BAD_DOWNLOAD_RESUME = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_BAD_DOWNLOAD_RESUME = 36
     * }
     */
    public static int CURLE_BAD_DOWNLOAD_RESUME() {
        return CURLE_BAD_DOWNLOAD_RESUME;
    }
    private static final int CURLE_FILE_COULDNT_READ_FILE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FILE_COULDNT_READ_FILE = 37
     * }
     */
    public static int CURLE_FILE_COULDNT_READ_FILE() {
        return CURLE_FILE_COULDNT_READ_FILE;
    }
    private static final int CURLE_LDAP_CANNOT_BIND = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_LDAP_CANNOT_BIND = 38
     * }
     */
    public static int CURLE_LDAP_CANNOT_BIND() {
        return CURLE_LDAP_CANNOT_BIND;
    }
    private static final int CURLE_LDAP_SEARCH_FAILED = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_LDAP_SEARCH_FAILED = 39
     * }
     */
    public static int CURLE_LDAP_SEARCH_FAILED() {
        return CURLE_LDAP_SEARCH_FAILED;
    }
    private static final int CURLE_OBSOLETE40 = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE40 = 40
     * }
     */
    public static int CURLE_OBSOLETE40() {
        return CURLE_OBSOLETE40;
    }
    private static final int CURLE_FUNCTION_NOT_FOUND = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FUNCTION_NOT_FOUND = 41
     * }
     */
    public static int CURLE_FUNCTION_NOT_FOUND() {
        return CURLE_FUNCTION_NOT_FOUND;
    }
    private static final int CURLE_ABORTED_BY_CALLBACK = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_ABORTED_BY_CALLBACK = 42
     * }
     */
    public static int CURLE_ABORTED_BY_CALLBACK() {
        return CURLE_ABORTED_BY_CALLBACK;
    }
    private static final int CURLE_BAD_FUNCTION_ARGUMENT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_BAD_FUNCTION_ARGUMENT = 43
     * }
     */
    public static int CURLE_BAD_FUNCTION_ARGUMENT() {
        return CURLE_BAD_FUNCTION_ARGUMENT;
    }
    private static final int CURLE_OBSOLETE44 = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE44 = 44
     * }
     */
    public static int CURLE_OBSOLETE44() {
        return CURLE_OBSOLETE44;
    }
    private static final int CURLE_INTERFACE_FAILED = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_INTERFACE_FAILED = 45
     * }
     */
    public static int CURLE_INTERFACE_FAILED() {
        return CURLE_INTERFACE_FAILED;
    }
    private static final int CURLE_OBSOLETE46 = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE46 = 46
     * }
     */
    public static int CURLE_OBSOLETE46() {
        return CURLE_OBSOLETE46;
    }
    private static final int CURLE_TOO_MANY_REDIRECTS = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_TOO_MANY_REDIRECTS = 47
     * }
     */
    public static int CURLE_TOO_MANY_REDIRECTS() {
        return CURLE_TOO_MANY_REDIRECTS;
    }
    private static final int CURLE_UNKNOWN_OPTION = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_UNKNOWN_OPTION = 48
     * }
     */
    public static int CURLE_UNKNOWN_OPTION() {
        return CURLE_UNKNOWN_OPTION;
    }
    private static final int CURLE_SETOPT_OPTION_SYNTAX = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SETOPT_OPTION_SYNTAX = 49
     * }
     */
    public static int CURLE_SETOPT_OPTION_SYNTAX() {
        return CURLE_SETOPT_OPTION_SYNTAX;
    }
    private static final int CURLE_OBSOLETE50 = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE50 = 50
     * }
     */
    public static int CURLE_OBSOLETE50() {
        return CURLE_OBSOLETE50;
    }
    private static final int CURLE_OBSOLETE51 = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE51 = 51
     * }
     */
    public static int CURLE_OBSOLETE51() {
        return CURLE_OBSOLETE51;
    }
    private static final int CURLE_GOT_NOTHING = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_GOT_NOTHING = 52
     * }
     */
    public static int CURLE_GOT_NOTHING() {
        return CURLE_GOT_NOTHING;
    }
    private static final int CURLE_SSL_ENGINE_NOTFOUND = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_ENGINE_NOTFOUND = 53
     * }
     */
    public static int CURLE_SSL_ENGINE_NOTFOUND() {
        return CURLE_SSL_ENGINE_NOTFOUND;
    }
    private static final int CURLE_SSL_ENGINE_SETFAILED = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_ENGINE_SETFAILED = 54
     * }
     */
    public static int CURLE_SSL_ENGINE_SETFAILED() {
        return CURLE_SSL_ENGINE_SETFAILED;
    }
    private static final int CURLE_SEND_ERROR = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SEND_ERROR = 55
     * }
     */
    public static int CURLE_SEND_ERROR() {
        return CURLE_SEND_ERROR;
    }
    private static final int CURLE_RECV_ERROR = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_RECV_ERROR = 56
     * }
     */
    public static int CURLE_RECV_ERROR() {
        return CURLE_RECV_ERROR;
    }
    private static final int CURLE_OBSOLETE57 = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE57 = 57
     * }
     */
    public static int CURLE_OBSOLETE57() {
        return CURLE_OBSOLETE57;
    }
    private static final int CURLE_SSL_CERTPROBLEM = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_CERTPROBLEM = 58
     * }
     */
    public static int CURLE_SSL_CERTPROBLEM() {
        return CURLE_SSL_CERTPROBLEM;
    }
    private static final int CURLE_SSL_CIPHER = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_CIPHER = 59
     * }
     */
    public static int CURLE_SSL_CIPHER() {
        return CURLE_SSL_CIPHER;
    }
    private static final int CURLE_PEER_FAILED_VERIFICATION = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_PEER_FAILED_VERIFICATION = 60
     * }
     */
    public static int CURLE_PEER_FAILED_VERIFICATION() {
        return CURLE_PEER_FAILED_VERIFICATION;
    }
    private static final int CURLE_BAD_CONTENT_ENCODING = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_BAD_CONTENT_ENCODING = 61
     * }
     */
    public static int CURLE_BAD_CONTENT_ENCODING() {
        return CURLE_BAD_CONTENT_ENCODING;
    }
    private static final int CURLE_OBSOLETE62 = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE62 = 62
     * }
     */
    public static int CURLE_OBSOLETE62() {
        return CURLE_OBSOLETE62;
    }
    private static final int CURLE_FILESIZE_EXCEEDED = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FILESIZE_EXCEEDED = 63
     * }
     */
    public static int CURLE_FILESIZE_EXCEEDED() {
        return CURLE_FILESIZE_EXCEEDED;
    }
    private static final int CURLE_USE_SSL_FAILED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_USE_SSL_FAILED = 64
     * }
     */
    public static int CURLE_USE_SSL_FAILED() {
        return CURLE_USE_SSL_FAILED;
    }
    private static final int CURLE_SEND_FAIL_REWIND = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SEND_FAIL_REWIND = 65
     * }
     */
    public static int CURLE_SEND_FAIL_REWIND() {
        return CURLE_SEND_FAIL_REWIND;
    }
    private static final int CURLE_SSL_ENGINE_INITFAILED = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_ENGINE_INITFAILED = 66
     * }
     */
    public static int CURLE_SSL_ENGINE_INITFAILED() {
        return CURLE_SSL_ENGINE_INITFAILED;
    }
    private static final int CURLE_LOGIN_DENIED = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_LOGIN_DENIED = 67
     * }
     */
    public static int CURLE_LOGIN_DENIED() {
        return CURLE_LOGIN_DENIED;
    }
    private static final int CURLE_TFTP_NOTFOUND = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_TFTP_NOTFOUND = 68
     * }
     */
    public static int CURLE_TFTP_NOTFOUND() {
        return CURLE_TFTP_NOTFOUND;
    }
    private static final int CURLE_TFTP_PERM = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_TFTP_PERM = 69
     * }
     */
    public static int CURLE_TFTP_PERM() {
        return CURLE_TFTP_PERM;
    }
    private static final int CURLE_REMOTE_DISK_FULL = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_REMOTE_DISK_FULL = 70
     * }
     */
    public static int CURLE_REMOTE_DISK_FULL() {
        return CURLE_REMOTE_DISK_FULL;
    }
    private static final int CURLE_TFTP_ILLEGAL = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_TFTP_ILLEGAL = 71
     * }
     */
    public static int CURLE_TFTP_ILLEGAL() {
        return CURLE_TFTP_ILLEGAL;
    }
    private static final int CURLE_TFTP_UNKNOWNID = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_TFTP_UNKNOWNID = 72
     * }
     */
    public static int CURLE_TFTP_UNKNOWNID() {
        return CURLE_TFTP_UNKNOWNID;
    }
    private static final int CURLE_REMOTE_FILE_EXISTS = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_REMOTE_FILE_EXISTS = 73
     * }
     */
    public static int CURLE_REMOTE_FILE_EXISTS() {
        return CURLE_REMOTE_FILE_EXISTS;
    }
    private static final int CURLE_TFTP_NOSUCHUSER = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_TFTP_NOSUCHUSER = 74
     * }
     */
    public static int CURLE_TFTP_NOSUCHUSER() {
        return CURLE_TFTP_NOSUCHUSER;
    }
    private static final int CURLE_OBSOLETE75 = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE75 = 75
     * }
     */
    public static int CURLE_OBSOLETE75() {
        return CURLE_OBSOLETE75;
    }
    private static final int CURLE_OBSOLETE76 = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_OBSOLETE76 = 76
     * }
     */
    public static int CURLE_OBSOLETE76() {
        return CURLE_OBSOLETE76;
    }
    private static final int CURLE_SSL_CACERT_BADFILE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_CACERT_BADFILE = 77
     * }
     */
    public static int CURLE_SSL_CACERT_BADFILE() {
        return CURLE_SSL_CACERT_BADFILE;
    }
    private static final int CURLE_REMOTE_FILE_NOT_FOUND = (int)78L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_REMOTE_FILE_NOT_FOUND = 78
     * }
     */
    public static int CURLE_REMOTE_FILE_NOT_FOUND() {
        return CURLE_REMOTE_FILE_NOT_FOUND;
    }
    private static final int CURLE_SSH = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSH = 79
     * }
     */
    public static int CURLE_SSH() {
        return CURLE_SSH;
    }
    private static final int CURLE_SSL_SHUTDOWN_FAILED = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_SHUTDOWN_FAILED = 80
     * }
     */
    public static int CURLE_SSL_SHUTDOWN_FAILED() {
        return CURLE_SSL_SHUTDOWN_FAILED;
    }
    private static final int CURLE_AGAIN = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_AGAIN = 81
     * }
     */
    public static int CURLE_AGAIN() {
        return CURLE_AGAIN;
    }
    private static final int CURLE_SSL_CRL_BADFILE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_CRL_BADFILE = 82
     * }
     */
    public static int CURLE_SSL_CRL_BADFILE() {
        return CURLE_SSL_CRL_BADFILE;
    }
    private static final int CURLE_SSL_ISSUER_ERROR = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_ISSUER_ERROR = 83
     * }
     */
    public static int CURLE_SSL_ISSUER_ERROR() {
        return CURLE_SSL_ISSUER_ERROR;
    }
    private static final int CURLE_FTP_PRET_FAILED = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_PRET_FAILED = 84
     * }
     */
    public static int CURLE_FTP_PRET_FAILED() {
        return CURLE_FTP_PRET_FAILED;
    }
    private static final int CURLE_RTSP_CSEQ_ERROR = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_RTSP_CSEQ_ERROR = 85
     * }
     */
    public static int CURLE_RTSP_CSEQ_ERROR() {
        return CURLE_RTSP_CSEQ_ERROR;
    }
    private static final int CURLE_RTSP_SESSION_ERROR = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_RTSP_SESSION_ERROR = 86
     * }
     */
    public static int CURLE_RTSP_SESSION_ERROR() {
        return CURLE_RTSP_SESSION_ERROR;
    }
    private static final int CURLE_FTP_BAD_FILE_LIST = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_FTP_BAD_FILE_LIST = 87
     * }
     */
    public static int CURLE_FTP_BAD_FILE_LIST() {
        return CURLE_FTP_BAD_FILE_LIST;
    }
    private static final int CURLE_CHUNK_FAILED = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_CHUNK_FAILED = 88
     * }
     */
    public static int CURLE_CHUNK_FAILED() {
        return CURLE_CHUNK_FAILED;
    }
    private static final int CURLE_NO_CONNECTION_AVAILABLE = (int)89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_NO_CONNECTION_AVAILABLE = 89
     * }
     */
    public static int CURLE_NO_CONNECTION_AVAILABLE() {
        return CURLE_NO_CONNECTION_AVAILABLE;
    }
    private static final int CURLE_SSL_PINNEDPUBKEYNOTMATCH = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_PINNEDPUBKEYNOTMATCH = 90
     * }
     */
    public static int CURLE_SSL_PINNEDPUBKEYNOTMATCH() {
        return CURLE_SSL_PINNEDPUBKEYNOTMATCH;
    }
    private static final int CURLE_SSL_INVALIDCERTSTATUS = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_INVALIDCERTSTATUS = 91
     * }
     */
    public static int CURLE_SSL_INVALIDCERTSTATUS() {
        return CURLE_SSL_INVALIDCERTSTATUS;
    }
    private static final int CURLE_HTTP2_STREAM = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_HTTP2_STREAM = 92
     * }
     */
    public static int CURLE_HTTP2_STREAM() {
        return CURLE_HTTP2_STREAM;
    }
    private static final int CURLE_RECURSIVE_API_CALL = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_RECURSIVE_API_CALL = 93
     * }
     */
    public static int CURLE_RECURSIVE_API_CALL() {
        return CURLE_RECURSIVE_API_CALL;
    }
    private static final int CURLE_AUTH_ERROR = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_AUTH_ERROR = 94
     * }
     */
    public static int CURLE_AUTH_ERROR() {
        return CURLE_AUTH_ERROR;
    }
    private static final int CURLE_HTTP3 = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_HTTP3 = 95
     * }
     */
    public static int CURLE_HTTP3() {
        return CURLE_HTTP3;
    }
    private static final int CURLE_QUIC_CONNECT_ERROR = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_QUIC_CONNECT_ERROR = 96
     * }
     */
    public static int CURLE_QUIC_CONNECT_ERROR() {
        return CURLE_QUIC_CONNECT_ERROR;
    }
    private static final int CURLE_PROXY = (int)97L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_PROXY = 97
     * }
     */
    public static int CURLE_PROXY() {
        return CURLE_PROXY;
    }
    private static final int CURLE_SSL_CLIENTCERT = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_SSL_CLIENTCERT = 98
     * }
     */
    public static int CURLE_SSL_CLIENTCERT() {
        return CURLE_SSL_CLIENTCERT;
    }
    private static final int CURLE_UNRECOVERABLE_POLL = (int)99L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_UNRECOVERABLE_POLL = 99
     * }
     */
    public static int CURLE_UNRECOVERABLE_POLL() {
        return CURLE_UNRECOVERABLE_POLL;
    }
    private static final int CURLE_TOO_LARGE = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_TOO_LARGE = 100
     * }
     */
    public static int CURLE_TOO_LARGE() {
        return CURLE_TOO_LARGE;
    }
    private static final int CURLE_ECH_REQUIRED = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLE_ECH_REQUIRED = 101
     * }
     */
    public static int CURLE_ECH_REQUIRED() {
        return CURLE_ECH_REQUIRED;
    }
    private static final int CURL_LAST = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURL_LAST = 102
     * }
     */
    public static int CURL_LAST() {
        return CURL_LAST;
    }
    private static final int CURLPX_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_OK = 0
     * }
     */
    public static int CURLPX_OK() {
        return CURLPX_OK;
    }
    private static final int CURLPX_BAD_ADDRESS_TYPE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_BAD_ADDRESS_TYPE = 1
     * }
     */
    public static int CURLPX_BAD_ADDRESS_TYPE() {
        return CURLPX_BAD_ADDRESS_TYPE;
    }
    private static final int CURLPX_BAD_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_BAD_VERSION = 2
     * }
     */
    public static int CURLPX_BAD_VERSION() {
        return CURLPX_BAD_VERSION;
    }
    private static final int CURLPX_CLOSED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_CLOSED = 3
     * }
     */
    public static int CURLPX_CLOSED() {
        return CURLPX_CLOSED;
    }
    private static final int CURLPX_GSSAPI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_GSSAPI = 4
     * }
     */
    public static int CURLPX_GSSAPI() {
        return CURLPX_GSSAPI;
    }
    private static final int CURLPX_GSSAPI_PERMSG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_GSSAPI_PERMSG = 5
     * }
     */
    public static int CURLPX_GSSAPI_PERMSG() {
        return CURLPX_GSSAPI_PERMSG;
    }
    private static final int CURLPX_GSSAPI_PROTECTION = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_GSSAPI_PROTECTION = 6
     * }
     */
    public static int CURLPX_GSSAPI_PROTECTION() {
        return CURLPX_GSSAPI_PROTECTION;
    }
    private static final int CURLPX_IDENTD = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_IDENTD = 7
     * }
     */
    public static int CURLPX_IDENTD() {
        return CURLPX_IDENTD;
    }
    private static final int CURLPX_IDENTD_DIFFER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_IDENTD_DIFFER = 8
     * }
     */
    public static int CURLPX_IDENTD_DIFFER() {
        return CURLPX_IDENTD_DIFFER;
    }
    private static final int CURLPX_LONG_HOSTNAME = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_LONG_HOSTNAME = 9
     * }
     */
    public static int CURLPX_LONG_HOSTNAME() {
        return CURLPX_LONG_HOSTNAME;
    }
    private static final int CURLPX_LONG_PASSWD = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_LONG_PASSWD = 10
     * }
     */
    public static int CURLPX_LONG_PASSWD() {
        return CURLPX_LONG_PASSWD;
    }
    private static final int CURLPX_LONG_USER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_LONG_USER = 11
     * }
     */
    public static int CURLPX_LONG_USER() {
        return CURLPX_LONG_USER;
    }
    private static final int CURLPX_NO_AUTH = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_NO_AUTH = 12
     * }
     */
    public static int CURLPX_NO_AUTH() {
        return CURLPX_NO_AUTH;
    }
    private static final int CURLPX_RECV_ADDRESS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_RECV_ADDRESS = 13
     * }
     */
    public static int CURLPX_RECV_ADDRESS() {
        return CURLPX_RECV_ADDRESS;
    }
    private static final int CURLPX_RECV_AUTH = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_RECV_AUTH = 14
     * }
     */
    public static int CURLPX_RECV_AUTH() {
        return CURLPX_RECV_AUTH;
    }
    private static final int CURLPX_RECV_CONNECT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_RECV_CONNECT = 15
     * }
     */
    public static int CURLPX_RECV_CONNECT() {
        return CURLPX_RECV_CONNECT;
    }
    private static final int CURLPX_RECV_REQACK = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_RECV_REQACK = 16
     * }
     */
    public static int CURLPX_RECV_REQACK() {
        return CURLPX_RECV_REQACK;
    }
    private static final int CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED = 17
     * }
     */
    public static int CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED() {
        return CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED;
    }
    private static final int CURLPX_REPLY_COMMAND_NOT_SUPPORTED = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_COMMAND_NOT_SUPPORTED = 18
     * }
     */
    public static int CURLPX_REPLY_COMMAND_NOT_SUPPORTED() {
        return CURLPX_REPLY_COMMAND_NOT_SUPPORTED;
    }
    private static final int CURLPX_REPLY_CONNECTION_REFUSED = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_CONNECTION_REFUSED = 19
     * }
     */
    public static int CURLPX_REPLY_CONNECTION_REFUSED() {
        return CURLPX_REPLY_CONNECTION_REFUSED;
    }
    private static final int CURLPX_REPLY_GENERAL_SERVER_FAILURE = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_GENERAL_SERVER_FAILURE = 20
     * }
     */
    public static int CURLPX_REPLY_GENERAL_SERVER_FAILURE() {
        return CURLPX_REPLY_GENERAL_SERVER_FAILURE;
    }
    private static final int CURLPX_REPLY_HOST_UNREACHABLE = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_HOST_UNREACHABLE = 21
     * }
     */
    public static int CURLPX_REPLY_HOST_UNREACHABLE() {
        return CURLPX_REPLY_HOST_UNREACHABLE;
    }
    private static final int CURLPX_REPLY_NETWORK_UNREACHABLE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_NETWORK_UNREACHABLE = 22
     * }
     */
    public static int CURLPX_REPLY_NETWORK_UNREACHABLE() {
        return CURLPX_REPLY_NETWORK_UNREACHABLE;
    }
    private static final int CURLPX_REPLY_NOT_ALLOWED = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_NOT_ALLOWED = 23
     * }
     */
    public static int CURLPX_REPLY_NOT_ALLOWED() {
        return CURLPX_REPLY_NOT_ALLOWED;
    }
    private static final int CURLPX_REPLY_TTL_EXPIRED = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_TTL_EXPIRED = 24
     * }
     */
    public static int CURLPX_REPLY_TTL_EXPIRED() {
        return CURLPX_REPLY_TTL_EXPIRED;
    }
    private static final int CURLPX_REPLY_UNASSIGNED = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REPLY_UNASSIGNED = 25
     * }
     */
    public static int CURLPX_REPLY_UNASSIGNED() {
        return CURLPX_REPLY_UNASSIGNED;
    }
    private static final int CURLPX_REQUEST_FAILED = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_REQUEST_FAILED = 26
     * }
     */
    public static int CURLPX_REQUEST_FAILED() {
        return CURLPX_REQUEST_FAILED;
    }
    private static final int CURLPX_RESOLVE_HOST = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_RESOLVE_HOST = 27
     * }
     */
    public static int CURLPX_RESOLVE_HOST() {
        return CURLPX_RESOLVE_HOST;
    }
    private static final int CURLPX_SEND_AUTH = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_SEND_AUTH = 28
     * }
     */
    public static int CURLPX_SEND_AUTH() {
        return CURLPX_SEND_AUTH;
    }
    private static final int CURLPX_SEND_CONNECT = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_SEND_CONNECT = 29
     * }
     */
    public static int CURLPX_SEND_CONNECT() {
        return CURLPX_SEND_CONNECT;
    }
    private static final int CURLPX_SEND_REQUEST = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_SEND_REQUEST = 30
     * }
     */
    public static int CURLPX_SEND_REQUEST() {
        return CURLPX_SEND_REQUEST;
    }
    private static final int CURLPX_UNKNOWN_FAIL = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_UNKNOWN_FAIL = 31
     * }
     */
    public static int CURLPX_UNKNOWN_FAIL() {
        return CURLPX_UNKNOWN_FAIL;
    }
    private static final int CURLPX_UNKNOWN_MODE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_UNKNOWN_MODE = 32
     * }
     */
    public static int CURLPX_UNKNOWN_MODE() {
        return CURLPX_UNKNOWN_MODE;
    }
    private static final int CURLPX_USER_REJECTED = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_USER_REJECTED = 33
     * }
     */
    public static int CURLPX_USER_REJECTED() {
        return CURLPX_USER_REJECTED;
    }
    private static final int CURLPX_LAST = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPX_LAST = 34
     * }
     */
    public static int CURLPX_LAST() {
        return CURLPX_LAST;
    }
    private static final int CURLPROXY_HTTP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPROXY_HTTP = 0
     * }
     */
    public static int CURLPROXY_HTTP() {
        return CURLPROXY_HTTP;
    }
    private static final int CURLPROXY_HTTP_1_0 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPROXY_HTTP_1_0 = 1
     * }
     */
    public static int CURLPROXY_HTTP_1_0() {
        return CURLPROXY_HTTP_1_0;
    }
    private static final int CURLPROXY_HTTPS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPROXY_HTTPS = 2
     * }
     */
    public static int CURLPROXY_HTTPS() {
        return CURLPROXY_HTTPS;
    }
    private static final int CURLPROXY_HTTPS2 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPROXY_HTTPS2 = 3
     * }
     */
    public static int CURLPROXY_HTTPS2() {
        return CURLPROXY_HTTPS2;
    }
    private static final int CURLPROXY_SOCKS4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPROXY_SOCKS4 = 4
     * }
     */
    public static int CURLPROXY_SOCKS4() {
        return CURLPROXY_SOCKS4;
    }
    private static final int CURLPROXY_SOCKS5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPROXY_SOCKS5 = 5
     * }
     */
    public static int CURLPROXY_SOCKS5() {
        return CURLPROXY_SOCKS5;
    }
    private static final int CURLPROXY_SOCKS4A = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CURLPROXY_SOCKS4A = 6
     * }
     */
    public static int CURLPROXY_SOCKS4A() {
        return CURLPROXY_SOCKS4A;
    }
}

